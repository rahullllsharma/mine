## Migrations
Migrations are processed when a data model has updated and we need to make the associated change in the database.
Migrations are implemented with [alembic](https://alembic.sqlalchemy.org/en/latest/).

### Data Models
The basis behind database migrations rest with data modeling.
Our codebase interacts with the database through `models`, which are effectively abstractions that allow us to interact with data in the database.
We are using [SQLModel](https://sqlmodel.tiangolo.com) to interact with the database, and the first step in interacting with data in the database we need to first declare a model.
Below is a simple example of a basic `user` model
```python
from typing import Optional
import uuid
from sqlmodel import Field

from worker_safety_service.models import SQLModel

class User(SQLModel, table=True):
    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    name: str
    email: str
    age: Optional[int]
```
In this case, every `user` that is created in the database _must_ have a `name` and `email` field stored in the database and we can optionally include an `age` field.

**Note: In order to have alembic recognize all of the models we care about, we need to import `SQLModel` from our `base` file, not directly from `sqlmodel`.**   

Then if we wanted to interact with the data in our database we do so _through_ the model.
For example, if we want to get all users who have Gmail addresses and print out each user, we would create code that runs something along the lines of
```python
from sqlmodel import select
from worker_safety_service.models import User, get_session

async with get_session() as session:
    statement = select(User).where(User.email.ilike('%gmail%'))
    for user in await session.exec(statement):
        print(user)
```
What's going on above is we're first importing the necessary criteria from `SQLModel` to set up a database connection and interact with the database.
The other imports are the global config, and the "fake" `User` model we've set up above.
We've then set up an engine, with which `SQLModel` creates an engine using the `create_engine` method.
The fetching of data occurs in the `with` context.
The general SQL statement that would look like
```sql
SELECT * FROM USER
WHERE LOWER(email) like '%gmail%';
```
`SQLModel` is, in effect, a wrapper around `SQLAlchemy` so even though a case-insensitive text search condition doesn't yet exist in `SQLModel`, we can use some of `SQLAlchemy`'s query methods as well.  That is where the `ilike` statement comes from.

Now that we see _how_ to interact with the database we need to touch on how to make the database look like our models.

### Updating models
Using the `User` model that we created before, let's assume that we want to include a `height` attribute.
Then the model, assuming it's an optional integer field that specifies a number of inches, would look like
```python
class User(SQLModel, table=True):
    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    name: str
    email: str
    age: Optional[int]
    height: Optional[int]
```
Now, after updating this model, we try to add a height to an existing user via the script
```python
async with AsyncSession(engine) as session:
    statement = select(User).where(User.name == 'Sample User')
    results = await session.exec(statement)
    user = results.one()

    user.height = 65
    session.add(user)
    await session.commit()
    await session.refresh(user)
```
Upon running this code we will get an error.
This is because, while we have updated the model to include the height, the database hasn't been updated to reflect this change.
So in a situation like this the `UPDATE` SQL method is trying to set a value in a column that doesn't yet exist.
This is where migrations come in; this is the functionality that allows us to create scripts to update the database based on how we've updated the models.

### Create a new revision
Revisions are what alembic calls individual migrations. They can be created manually or autogenerated from our models.

``` shell
# Create an empty revision file
poetry run alembic revision -m "A new empty revision"

# Autogenerate a revision file after creating the model definitions
poetry run alembic revision -m "An autogenerated revision" --autogenerate
```

In both cases, the revision files are added to the `migrations/versions` directory.
When this action is performed, a file that looks something like what is below is created
```python
"""Initial migration

Revision ID: c703c8abd734
Revises:
Create Date: 2021-12-01 10:13:25.007175

"""
import sqlalchemy as sa
import sqlmodel
from alembic import op

# revision identifiers, used by Alembic.
revision = "c703c8abd734"
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    pass

def downgrade():
    pass
```
What you would end up doing is adding in the database updates that are required to match your model.
Thus, in a situation like where we added a `height` attribute to the `User` model, we would add in
```python
def upgrade():
    op.add_column("user_model", sa.Column("height", sa.Integer(), nullable=True))

def downgrade():
    op.drop_column("user_model", "height")
```
where `user_model` is the database name of the table.
If we used the `--autogenerate` flag then a few more options would be included but this is a minimum required code to update the database as needed.  

As it stands, though, the database is still not updated yet.
We have created our migration file but we have not yet applied the migrations to the database.

### Upgrade database to latest revision
Executing the following command will execute all pending migrations.

``` shell
poetry run alembic upgrade head
```
This command will apply any unapplied migrations to the database.
So, if you are running the code locally with a `Postgres` instance either running on your machine or in a Docker container and you're getting set up for the first time, all you need to do is be in the directory where the `alembic.ini` file is and run the above command and all of the necessary changes will be applied to your database instance.
There are more explicit modifiers that are possible with alembic, and they can be found [here](https://alembic.sqlalchemy.org/en/latest/tutorial.html#partial-revision-identifiers) and [here](https://alembic.sqlalchemy.org/en/latest/tutorial.html#relative-migration-identifiers), but for the purposes of upgrading the database to the most recent version, the primary command that will be needed is `alembic upgrade head` (in whatever environment you're working).

### Automated database migrations
There is a codefresh file that has been set up at the root of the project, `codefresh-db-migrations.yml` that will automatically apply any and all migrations to the staging database if the staging database is not fully upgraded.
The only thing that needs to be done is make sure that all migrations that you want to have applied are committed and included in PRs to master, and that they are consistent.
This last step means that any migrations you want to apply must start with the latest staging revision as the `down_revision` in the first migration file.

For example, if you are adding three migrations to the codebase, the "first" one in the group of three must have the staging revision as the `down_revision`, while the other two should progress naturally in the manner that Alembic does.

### Rolling back migrations --> TODO
The process for rolling back migrations is slightly more complicated.
There are a few ways that migrations can be rolled back
- Roll back `n` steps via `alembic downgrade -n`
- Upgrade to a specific revision
- Upgrade to a specific revision +/- `n` number of revisions

The problem with all three of these is that they all require user input, which is not something that is typically very easy to include in an automated pipeline process.
There are a couple of solutions that have been hypothesized
- Removing migration file 
  - The first thought to resolving this was to just remove the migration file that caused the error and re-upgrade to head.
  Unfortunately if the file with the revision ID that is associated with the latest version of the database is removed then this will make downgrading impossible.
  - Passing information in via GitHub commit messages and labels

#### GitHub and Codefresh
Codefresh has many [variables](https://codefresh.io/docs/docs/codefresh-yaml/variables/) that can be used in the `.yml` file, including the commit message and any pull request labels.
There are three subsequent possibilities for kicking off the process
- Adding a `pending-approval` stage to the `codefresh-db-migrations.yml` file that will not allow the code to reach the rollback stage unless manually triggered.
- Adding a string in the commit message that indicates that a rollback should occur, something like including a `--rollback -2` in the commit message.
- Checking to see if the `${{CF_PULL_REQUEST_LABELS}}` variable includes a label like `rollback`

Regardless of the methodology by which the process is kicked off, it is likely that we'll need a process like the second example in the kickoff options to tell alembic how many versions to downgrade or to which revision it should move to.
Below is a sample config that includes all three possibilities above
```yaml
approval_to_downgrade_staging:
  type: pending-approval
  title: Approval to Downgrade Staging DB
  description: Approve this step to roll back the database
  fail_fast: false
  stage: staging_db_rollback
  when:
    condition:
      all:
        masterBranch: '"${{CF_BRANCH}}" == "main"'
        whenVarExists: 'includes("${{CF_PULL_REQUEST_LABELS}}, "rollback") == true && includes("${{CF_COMMIT_MESSAGE}}, "--rollback")'

downgrade:
  title: "Run migration downgrade"
  type: freestyle
  image: python:3.10.0
  stage: staging_db_rollback
  working_directory: "${{clone}}"
  environment:
    - POSTGRES_HOST=postgres.worker-safety
    - POSTGRES_USER=${{POSTGRES_USER}}
    - POSTGRES_PASSWORD=${{POSTGRES_PASS_STAGING}}
    - POSTGRES_DB=${{POSTGRES_DB_STAGING}}
  commands:
    - python -m venv env
    - sh env/bin/activate
    - pip install alembic==1.7.5 pydantic==1.8.2 sqlmodel==0.0.4
    - (./migrations/scripts/roll-back.sh ${{CF_COMMIT_MESSAGE}})
    - echo "Done"
  when:
    steps:
      - name: approval_to_downgrade_staging
        on:
          - approved
    condition:
      all:
        masterBranch: '"${{CF_BRANCH}}" == "main"'
```
Then, as referenced in the above config, we could include a script that would search for the `--rollback` condition in the commit message and apply the appropriate alembic downgrade or upgrade to a specific revision.
This is purely a thought experiment that likely requires a more detailed discussion before implementation.
