import { PartialDeep, Writable, RequireAtLeastOne } from 'type-fest';
import { MediaValues } from 'css-mediaquery';

declare class MockedDOMRectReadOnly implements DOMRectReadOnly {
    _x: number;
    _y: number;
    _width: number;
    _height: number;
    constructor(x?: number, y?: number, width?: number, height?: number);
    get x(): number;
    set x(_value: number);
    get y(): number;
    set y(_value: number);
    get width(): number;
    set width(_value: number);
    get height(): number;
    set height(_value: number);
    get left(): number;
    set left(_value: number);
    get right(): number;
    set right(_value: number);
    get top(): number;
    set top(_value: number);
    get bottom(): number;
    set bottom(_value: number);
    toJSON(): {
        bottom: number;
        height: number;
        left: number;
        right: number;
        top: number;
        width: number;
        x: number;
        y: number;
    };
    toString(): string;
}
declare class MockedDOMRect extends MockedDOMRectReadOnly implements DOMRect {
    constructor(x?: number, y?: number, width?: number, height?: number);
    get x(): number;
    set x(_value: number);
    get y(): number;
    set y(_value: number);
    get width(): number;
    set width(_value: number);
    get height(): number;
    set height(_value: number);
    toString(): string;
}

declare type IntersectionDescription = Omit<PartialDeep<Writable<IntersectionObserverEntry>>, 'target'> & {
    target?: Element;
};
declare type NodeIntersectionDescription = {
    node: HTMLElement;
    desc?: IntersectionDescription;
};
declare class MockedIntersectionObserver implements IntersectionObserver {
    nodes: HTMLElement[];
    nodeStates: IntersectionObserverEntry[];
    callback: IntersectionObserverCallback;
    readonly root: Element | Document | null;
    readonly rootMargin: string;
    readonly thresholds: ReadonlyArray<number>;
    timeOrigin: number;
    constructor(callback: IntersectionObserverCallback, options?: IntersectionObserverInit | undefined);
    observe(node: HTMLElement): void;
    unobserve(node: HTMLElement): void;
    disconnect(): void;
    triggerNode(node: HTMLElement, desc: IntersectionDescription): void;
    triggerNodes(nodeDescriptions: NodeIntersectionDescription[]): void;
    takeRecords(): IntersectionObserverEntry[];
}
declare function mockIntersectionObserver(): {
    enterAll: (desc?: IntersectionDescription) => void;
    enterNode: (node: HTMLElement, desc?: IntersectionDescription) => void;
    enterNodes: (nodeDescriptions: (NodeIntersectionDescription | HTMLElement)[]) => void;
    leaveAll: (desc?: IntersectionDescription) => void;
    leaveNode: (node: HTMLElement, desc?: IntersectionDescription) => void;
    triggerNodes: (nodeDescriptions: (NodeIntersectionDescription | HTMLElement)[]) => void;
    leaveNodes: (nodeDescriptions: (NodeIntersectionDescription | HTMLElement)[]) => void;
    cleanup: () => void;
};

declare type ResizeObserverSizeInput = RequireAtLeastOne<ResizeObserverSize>;
declare type SizeInput = {
    borderBoxSize: ResizeObserverSizeInput[] | ResizeObserverSizeInput;
    contentBoxSize: ResizeObserverSizeInput[] | ResizeObserverSizeInput;
};
declare type Size = RequireAtLeastOne<SizeInput>;
declare class MockedResizeObserver implements ResizeObserver {
    callback: ResizeObserverCallback;
    observationTargets: Set<HTMLElement>;
    activeTargets: Set<HTMLElement>;
    constructor(callback: ResizeObserverCallback);
    observe: (node: HTMLElement) => void;
    unobserve: (node: HTMLElement) => void;
    disconnect: () => void;
}
declare function mockResizeObserver(): {
    getObservers: (element?: HTMLElement) => MockedResizeObserver[];
    getObservedElements: (observer?: ResizeObserver) => HTMLElement[];
    mockElementSize: (element: HTMLElement, size: Size) => void;
    resize: (elements?: HTMLElement | HTMLElement[], { ignoreImplicit }?: {
        ignoreImplicit?: boolean | undefined;
    }) => void;
};

declare const mockElementBoundingClientRect: (element: HTMLElement, { x, y, width, height, }: Partial<Pick<DOMRect, 'x' | 'y' | 'width' | 'height'>>) => () => DOMRect;

/**
 * A tool that allows testing components that use js media queries (matchMedia)
 * `mockViewport` must be called before rendering the component
 * @example using react testing library
 *
 *  const viewport = mockViewport({ width: '320px', height: '568px' })
 *
 *  const { getByText, queryByText } = render(<TestComponent />)
 *
 *  expect(getByText('Content visible only in the phone')).toBeInTheDocument()
 *  expect(queryByText('Content visible only on desktop')).not.toBeInTheDocument()
 *
 *  act(() => {
 *    viewport.set({ width: '1440px', height: '900px' })
 *  })
 *
 *  expect(queryByText('Content visible only on the phone')).not.toBeInTheDocument()
 *  expect(getByText('Content visible only on desktop')).toBeInTheDocument()
 *
 *  viewport.cleanup()
 *
 */
declare type ViewportDescription = Partial<MediaValues>;
declare type MockViewport = {
    cleanup: () => void;
    set: (newDesc: ViewportDescription) => void;
};
declare function mockViewport(desc: ViewportDescription): MockViewport;
declare function mockViewportForTestGroup(desc: ViewportDescription): void;

declare function mockAnimationsApi(): void;

export { IntersectionDescription, MockViewport, MockedDOMRect, MockedIntersectionObserver, NodeIntersectionDescription, ViewportDescription, mockAnimationsApi, mockElementBoundingClientRect, mockIntersectionObserver, mockResizeObserver, mockViewport, mockViewportForTestGroup };
