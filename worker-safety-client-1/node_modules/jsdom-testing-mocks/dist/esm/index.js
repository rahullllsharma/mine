var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/mocks/size/DOMRect.ts
var protectedProps = ["_x", "_y", "_width", "_height"];
var MockedDOMRectReadOnly = class {
  constructor(x = 0, y = 0, width = 0, height = 0) {
    this._x = x;
    this._y = y;
    this._width = width;
    this._height = height;
    protectedProps.forEach((prop) => {
      const descriptor = Object.getOwnPropertyDescriptor(this, prop);
      if (descriptor) {
        Object.defineProperty(this, prop, {
          ...descriptor,
          enumerable: false
        });
      }
    });
  }
  get x() {
    return this._x;
  }
  set x(_value) {
  }
  get y() {
    return this._y;
  }
  set y(_value) {
  }
  get width() {
    return this._width;
  }
  set width(_value) {
  }
  get height() {
    return this._height;
  }
  set height(_value) {
  }
  get left() {
    return this._x;
  }
  set left(_value) {
  }
  get right() {
    return this._x + Math.max(0, this._width);
  }
  set right(_value) {
  }
  get top() {
    return this._y;
  }
  set top(_value) {
  }
  get bottom() {
    return this._y + Math.max(0, this._height);
  }
  set bottom(_value) {
  }
  toJSON() {
    return {
      bottom: this.bottom,
      height: this.height,
      left: this.left,
      right: this.right,
      top: this.top,
      width: this.width,
      x: this.x,
      y: this.y
    };
  }
  toString() {
    return "[object DOMRectReadOnly]";
  }
};
var MockedDOMRect = class extends MockedDOMRectReadOnly {
  constructor(x = 0, y = 0, width = 0, height = 0) {
    super(x, y, width, height);
  }
  get x() {
    return super.x;
  }
  set x(_value) {
    this._x = _value;
  }
  get y() {
    return super.y;
  }
  set y(_value) {
    this._y = _value;
  }
  get width() {
    return super.width;
  }
  set width(_value) {
    this._width = _value;
  }
  get height() {
    return super.height;
  }
  set height(_value) {
    this._height = _value;
  }
  toString() {
    return "[object DOMRect]";
  }
};
if (typeof DOMRectReadOnly === "undefined") {
  Object.defineProperty(window, "DOMRectReadOnly", {
    writable: true,
    configurable: true,
    value: MockedDOMRectReadOnly
  });
}
if (typeof DOMRect === "undefined") {
  Object.defineProperty(window, "DOMRect", {
    writable: true,
    configurable: true,
    value: MockedDOMRect
  });
}

// src/mocks/intersection-observer.ts
var defaultState = {
  observers: []
};
var state = { ...defaultState };
function isElement(tested) {
  return typeof HTMLElement === "object" ? tested instanceof HTMLElement : Boolean(tested) && typeof tested === "object" && tested !== null && tested.nodeType === 1 && typeof tested.nodeName === "string";
}
function getObserversByNode(node) {
  return state.observers.filter((observer) => observer.nodes.includes(node));
}
function normalizeNodeDescriptions(nodeDescriptions) {
  return nodeDescriptions.map((nodeDesc) => {
    if (isElement(nodeDesc)) {
      return { node: nodeDesc };
    }
    return nodeDesc;
  });
}
function getNodeDescriptionsByObserver(nodeDescriptions) {
  const observerNodes = [];
  nodeDescriptions.forEach(({ node, desc }) => {
    const observers = getObserversByNode(node);
    observers.forEach((observer) => {
      const observerNode = observerNodes.find(({ observer: obs }) => obs === observer);
      if (observerNode) {
        observerNode.nodeDescriptions.push({ node, desc });
      } else {
        observerNodes.push({
          observer,
          nodeDescriptions: [{ node, desc }]
        });
      }
    });
  });
  return observerNodes;
}
function findNodeIndex(nodes, node) {
  const index = nodes.findIndex((nodeInArray) => node.isSameNode(nodeInArray));
  if (index === -1) {
    throw new Error("IntersectionObserver mock: node not found");
  }
  return index;
}
var MockedIntersectionObserver = class {
  constructor(callback, options) {
    this.nodes = [];
    this.nodeStates = [];
    this.root = null;
    this.rootMargin = "0px 0px 0px 0px";
    this.thresholds = [0];
    this.timeOrigin = 0;
    this.callback = callback;
    if (options) {
      if (typeof options.root !== "undefined") {
        this.root = options.root;
      }
      if (typeof options.rootMargin !== "undefined") {
        this.rootMargin = options.rootMargin;
      }
      if (typeof options.threshold !== "undefined") {
        this.thresholds = Array.isArray(options.threshold) ? options.threshold : [options.threshold];
      }
    }
    this.timeOrigin = performance.now();
    state.observers.push(this);
  }
  observe(node) {
    this.nodes.push(node);
    this.nodeStates.push({
      isIntersecting: false,
      target: node,
      time: performance.now() - this.timeOrigin,
      rootBounds: new DOMRectReadOnly(),
      intersectionRect: new DOMRectReadOnly(),
      intersectionRatio: 0,
      boundingClientRect: new DOMRectReadOnly()
    });
  }
  unobserve(node) {
    const index = this.nodes.findIndex((value) => value.isSameNode(node));
    this.nodes.splice(index, 1);
    this.nodeStates.splice(index, 1);
  }
  disconnect() {
    this.nodes = [];
    this.nodeStates = [];
  }
  triggerNode(node, desc) {
    const index = findNodeIndex(this.nodes, node);
    const nodeState = this.nodeStates[index];
    this.nodeStates[index] = {
      ...nodeState,
      time: performance.now() - this.timeOrigin,
      ...desc
    };
    this.callback([this.nodeStates[index]], this);
  }
  triggerNodes(nodeDescriptions) {
    const nodeIndexes = nodeDescriptions.map(({ node }) => findNodeIndex(this.nodes, node));
    const nodeStates = nodeDescriptions.map(({ desc }, index) => {
      const newState = {
        ...this.nodeStates[nodeIndexes[index]],
        time: performance.now() - this.timeOrigin,
        ...desc
      };
      this.nodeStates[nodeIndexes[index]] = newState;
      return newState;
    });
    this.callback(nodeStates, this);
  }
  takeRecords() {
    return [];
  }
};
function mockIntersectionObserver() {
  const savedImplementation = window.IntersectionObserver;
  Object.defineProperty(window, "IntersectionObserver", {
    writable: true,
    configurable: true,
    value: MockedIntersectionObserver
  });
  afterAll(() => {
    window.IntersectionObserver = savedImplementation;
  });
  return {
    enterAll: (desc) => {
      state.observers.forEach((observer) => {
        const nodeDescriptions = observer.nodes.map((node) => ({
          node,
          desc: {
            intersectionRatio: 1,
            ...desc,
            isIntersecting: true
          }
        }));
        observer.triggerNodes(nodeDescriptions);
      });
    },
    enterNode: (node, desc) => {
      const observers = getObserversByNode(node);
      observers.forEach((observer) => {
        observer.triggerNode(node, {
          intersectionRatio: 1,
          ...desc,
          isIntersecting: true
        });
      });
    },
    enterNodes: (nodeDescriptions) => {
      const normalizedNodeDescriptions = normalizeNodeDescriptions(nodeDescriptions);
      const observerNodes = getNodeDescriptionsByObserver(normalizedNodeDescriptions);
      observerNodes.forEach(({ observer, nodeDescriptions: nodeDescriptions2 }) => {
        observer.triggerNodes(nodeDescriptions2.map(({ node, desc }) => ({
          node,
          desc: { intersectionRatio: 1, ...desc, isIntersecting: true }
        })));
      });
    },
    leaveAll: (desc) => {
      state.observers.forEach((observer) => {
        const nodeDescriptions = observer.nodes.map((node) => ({
          node,
          desc: {
            intersectionRatio: 0,
            ...desc,
            isIntersecting: false
          }
        }));
        observer.triggerNodes(nodeDescriptions);
      });
    },
    leaveNode: (node, desc) => {
      const observers = getObserversByNode(node);
      observers.forEach((observer) => {
        observer.triggerNode(node, {
          intersectionRatio: 0,
          ...desc,
          isIntersecting: false
        });
      });
    },
    triggerNodes: (nodeDescriptions) => {
      const normalizedNodeDescriptions = normalizeNodeDescriptions(nodeDescriptions);
      const observerNodes = getNodeDescriptionsByObserver(normalizedNodeDescriptions);
      observerNodes.forEach(({ observer, nodeDescriptions: nodeDescriptions2 }) => {
        observer.triggerNodes(nodeDescriptions2);
      });
    },
    leaveNodes: (nodeDescriptions) => {
      const normalizedNodeDescriptions = normalizeNodeDescriptions(nodeDescriptions);
      const observerNodes = getNodeDescriptionsByObserver(normalizedNodeDescriptions);
      observerNodes.forEach(({ observer, nodeDescriptions: nodeDescriptions2 }) => {
        observer.triggerNodes(nodeDescriptions2.map(({ node, desc }) => ({
          node,
          desc: { intersectionRatio: 0, ...desc, isIntersecting: false }
        })));
      });
    },
    cleanup: () => {
      window.IntersectionObserver = savedImplementation;
      state.observers = [];
    }
  };
}

// src/mocks/resize-observer.ts
var state2 = {
  observers: [],
  targetObservers: /* @__PURE__ */ new Map(),
  elementSizes: /* @__PURE__ */ new Map()
};
function resetState() {
  state2.observers = [];
  state2.targetObservers = /* @__PURE__ */ new Map();
  state2.elementSizes = /* @__PURE__ */ new Map();
}
function defineResizeObserverSize(input) {
  return {
    blockSize: input.blockSize ?? 0,
    inlineSize: input.inlineSize ?? 0
  };
}
var MockedResizeObserver = class {
  constructor(callback) {
    this.observationTargets = /* @__PURE__ */ new Set();
    this.activeTargets = /* @__PURE__ */ new Set();
    this.observe = (node) => {
      this.observationTargets.add(node);
      this.activeTargets.add(node);
      if (state2.targetObservers.has(node)) {
        state2.targetObservers.get(node).push(this);
      } else {
        state2.targetObservers.set(node, [this]);
      }
    };
    this.unobserve = (node) => {
      this.observationTargets.delete(node);
      const targetObservers = state2.targetObservers.get(node);
      if (targetObservers) {
        const index = targetObservers.findIndex((mro) => mro === this);
        targetObservers.splice(index, 1);
        if (targetObservers.length === 0) {
          state2.targetObservers.delete(node);
        }
      }
    };
    this.disconnect = () => {
      this.observationTargets.clear();
      for (const node of this.observationTargets) {
        const targetObservers = state2.targetObservers.get(node);
        if (targetObservers) {
          const index = targetObservers.findIndex((mro) => mro === this);
          targetObservers.splice(index, 1);
          if (targetObservers.length === 0) {
            state2.targetObservers.delete(node);
          }
        }
      }
    };
    this.callback = callback;
    state2.observers.push(this);
  }
};
function elementToEntry(element) {
  const boundingClientRect = element.getBoundingClientRect();
  let sizes = state2.elementSizes.get(element);
  if (!sizes) {
    sizes = {
      borderBoxSize: [
        {
          blockSize: boundingClientRect.width,
          inlineSize: boundingClientRect.height
        }
      ],
      contentBoxSize: [
        {
          blockSize: boundingClientRect.width,
          inlineSize: boundingClientRect.height
        }
      ],
      contentRect: boundingClientRect
    };
  }
  if (sizes.contentRect.width === 0 && sizes.contentRect.height === 0) {
    return null;
  }
  return {
    borderBoxSize: Object.freeze(sizes.borderBoxSize),
    contentBoxSize: Object.freeze(sizes.contentBoxSize),
    contentRect: sizes.contentRect,
    devicePixelContentBoxSize: Object.freeze(sizes.contentBoxSize.map((size) => ({
      blockSize: size.blockSize * window.devicePixelRatio,
      inlineSize: size.inlineSize * window.devicePixelRatio
    }))),
    target: element
  };
}
function mockResizeObserver() {
  const savedImplementation = window.ResizeObserver;
  Object.defineProperty(window, "ResizeObserver", {
    writable: true,
    configurable: true,
    value: MockedResizeObserver
  });
  afterEach(() => {
    resetState();
  });
  afterAll(() => {
    window.ResizeObserver = savedImplementation;
  });
  return {
    getObservers: (element) => {
      if (element) {
        return [...state2.targetObservers.get(element) ?? []];
      }
      return [...state2.observers];
    },
    getObservedElements: (observer) => {
      if (observer) {
        return [...observer.observationTargets];
      }
      return [...state2.targetObservers.keys()];
    },
    mockElementSize: (element, size) => {
      let contentBoxSize;
      let borderBoxSize;
      if (!size.borderBoxSize && size.contentBoxSize) {
        if (!Array.isArray(size.contentBoxSize)) {
          size.contentBoxSize = [size.contentBoxSize];
        }
        contentBoxSize = size.contentBoxSize.map(defineResizeObserverSize);
        borderBoxSize = contentBoxSize;
      } else if (size.borderBoxSize && !size.contentBoxSize) {
        if (!Array.isArray(size.borderBoxSize)) {
          size.borderBoxSize = [size.borderBoxSize];
        }
        contentBoxSize = size.borderBoxSize.map(defineResizeObserverSize);
        borderBoxSize = contentBoxSize;
      } else if (size.borderBoxSize && size.contentBoxSize) {
        if (!Array.isArray(size.borderBoxSize)) {
          size.borderBoxSize = [size.borderBoxSize];
        }
        if (!Array.isArray(size.contentBoxSize)) {
          size.contentBoxSize = [size.contentBoxSize];
        }
        contentBoxSize = size.contentBoxSize.map(defineResizeObserverSize);
        borderBoxSize = size.borderBoxSize.map(defineResizeObserverSize);
        if (borderBoxSize.length !== contentBoxSize.length) {
          throw new Error("Both borderBoxSize and contentBoxSize must have the same amount of elements.");
        }
      } else {
        throw new Error("Neither borderBoxSize nor contentBoxSize was provided.");
      }
      contentBoxSize.forEach((size2, index) => {
        if (size2.blockSize < 0) {
          throw new Error(`contentBoxSize[${index}].blockSize must not be negative.`);
        }
        if (size2.inlineSize < 0) {
          throw new Error(`contentBoxSize[${index}].inlineSize must not be negative.`);
        }
      });
      borderBoxSize.forEach((size2, index) => {
        if (size2.blockSize < 0) {
          throw new Error(`borderBoxSize[${index}].blockSize must not be negative.`);
        }
        if (size2.inlineSize < 0) {
          throw new Error(`borderBoxSize[${index}].inlineSize must not be negative.`);
        }
      });
      const contentRect = new DOMRect(0, 0, contentBoxSize.reduce((acc, size2) => acc + size2.inlineSize, 0), contentBoxSize.reduce((acc, size2) => acc + size2.blockSize, 0));
      state2.elementSizes.set(element, {
        contentBoxSize,
        borderBoxSize,
        contentRect
      });
    },
    resize: (elements = [], { ignoreImplicit = false } = {}) => {
      if (!Array.isArray(elements)) {
        elements = [elements];
      }
      for (const observer of state2.observers) {
        const observedSubset = elements.filter((element) => observer.observationTargets.has(element));
        const observedSubsetAndActive = /* @__PURE__ */ new Set([
          ...observedSubset,
          ...ignoreImplicit ? [] : observer.activeTargets
        ]);
        observer.activeTargets.clear();
        const entries = Array.from(observedSubsetAndActive).map(elementToEntry).filter(Boolean);
        if (entries.length > 0) {
          observer.callback(entries, observer);
        }
      }
    }
  };
}
var { mockElementSize } = mockResizeObserver();
mockElementSize(document.body, {
  contentBoxSize: [{ blockSize: 100, inlineSize: 100 }]
});

// src/mocks/size/size.ts
var mockElementBoundingClientRect = (element, {
  x = 0,
  y = 0,
  width = 0,
  height = 0
}) => {
  const savedImplementation = element.getBoundingClientRect;
  element.getBoundingClientRect = jest.fn(() => new DOMRectReadOnly(x, y, width, height));
  return savedImplementation;
};

// src/mocks/viewport.ts
import mediaQuery from "css-mediaquery";

// src/mocks/MediaQueryListEvent.ts
var MockedMediaQueryListEvent = class extends Event {
  constructor(type, eventInitDict = {}) {
    super(type);
    this.media = eventInitDict.media ?? "";
    this.matches = eventInitDict.matches ?? false;
  }
};
if (typeof MediaQueryListEvent === "undefined") {
  Object.defineProperty(window, "MediaQueryListEvent", {
    writable: true,
    configurable: true,
    value: MockedMediaQueryListEvent
  });
}

// src/mocks/viewport.ts
function isEventListenerObject(obj) {
  return obj.handleEvent !== void 0;
}
function mockViewport(desc) {
  const state3 = {
    currentDesc: desc,
    oldListeners: [],
    listeners: []
  };
  const savedImplementation = window.matchMedia;
  const addOldListener = (list, matches, listener) => {
    state3.oldListeners.push({ listener, matches, list });
  };
  const removeOldListener = (listenerToRemove) => {
    const index = state3.oldListeners.findIndex(({ listener }) => listener === listenerToRemove);
    state3.oldListeners.splice(index, 1);
  };
  const addListener = (list, matches, listener) => {
    state3.listeners.push({ listener, matches, list });
  };
  const removeListener = (listenerToRemove) => {
    const index = state3.listeners.findIndex(({ listener }) => listener === listenerToRemove);
    state3.listeners.splice(index, 1);
  };
  Object.defineProperty(window, "matchMedia", {
    writable: true,
    value: (query) => ({
      get matches() {
        return mediaQuery.match(query, state3.currentDesc);
      },
      media: query,
      onchange: null,
      addListener: function(listener) {
        if (listener) {
          addOldListener(this, this.matches, listener);
        }
      },
      removeListener: (listener) => {
        if (listener) {
          removeOldListener(listener);
        }
      },
      addEventListener: function(eventType, listener) {
        if (eventType === "change") {
          addListener(this, this.matches, listener);
        }
      },
      removeEventListener: (eventType, listener) => {
        if (eventType === "change") {
          if (isEventListenerObject(listener)) {
            removeListener(listener.handleEvent);
          } else {
            removeListener(listener);
          }
        }
      },
      dispatchEvent: jest.fn()
    })
  });
  return {
    cleanup: () => {
      window.matchMedia = savedImplementation;
    },
    set: (newDesc) => {
      state3.currentDesc = newDesc;
      state3.listeners.forEach(({ listener, matches, list }, listenerIndex) => {
        const newMatches = list.matches;
        if (newMatches !== matches) {
          const changeEvent = new MediaQueryListEvent("change", {
            matches: newMatches,
            media: list.media
          });
          if (isEventListenerObject(listener)) {
            listener.handleEvent(changeEvent);
          } else {
            listener.call(list, changeEvent);
          }
          state3.listeners[listenerIndex].matches = newMatches;
        }
      });
      state3.oldListeners.forEach(({ listener, matches, list }, listenerIndex) => {
        const newMatches = list.matches;
        if (newMatches !== matches) {
          const changeEvent = new MediaQueryListEvent("change", {
            matches: newMatches,
            media: list.media
          });
          listener.call(list, changeEvent);
          state3.oldListeners[listenerIndex].matches = newMatches;
        }
      });
    }
  };
}
function mockViewportForTestGroup(desc) {
  let viewport;
  beforeAll(() => {
    viewport = mockViewport(desc);
  });
  afterAll(() => {
    viewport.cleanup();
  });
}

// src/mocks/web-animations-api/AnimationEffect.ts
var _timing, _getNormalizedDuration, getNormalizedDuration_fn;
var _MockedAnimationEffect = class {
  constructor() {
    __privateAdd(this, _getNormalizedDuration);
    __privateAdd(this, _timing, {
      delay: 0,
      direction: "normal",
      duration: "auto",
      easing: "linear",
      endDelay: 0,
      fill: "auto",
      iterationStart: 0,
      iterations: 1
    });
    if (this.constructor === _MockedAnimationEffect) {
      throw new TypeError("Illegal constructor");
    }
  }
  getTiming() {
    return __privateGet(this, _timing);
  }
  getComputedTiming() {
    const duration = __privateMethod(this, _getNormalizedDuration, getNormalizedDuration_fn).call(this);
    const activeDuration = __privateGet(this, _timing).iterations === Infinity ? Infinity : duration * (__privateGet(this, _timing).iterations ?? 1);
    const endTime = __privateGet(this, _timing).iterations === Infinity ? Infinity : Math.max((__privateGet(this, _timing).delay ?? 0) + activeDuration + (__privateGet(this, _timing).endDelay ?? 0), 0);
    const currentIteration = null;
    return {
      ...__privateGet(this, _timing),
      duration,
      fill: __privateGet(this, _timing).fill === "auto" ? "none" : __privateGet(this, _timing).fill,
      activeDuration,
      currentIteration: __privateGet(this, _timing).iterations === Infinity ? null : currentIteration,
      endTime,
      localTime: null,
      progress: null
    };
  }
  updateTiming(timing) {
    Object.assign(__privateGet(this, _timing), timing);
  }
};
var MockedAnimationEffect = _MockedAnimationEffect;
_timing = new WeakMap();
_getNormalizedDuration = new WeakSet();
getNormalizedDuration_fn = function() {
  if (typeof __privateGet(this, _timing).duration === "string") {
    return 0;
  }
  return __privateGet(this, _timing).duration ?? 0;
};
function mockAnimationEffect() {
  if (typeof AnimationEffect === "undefined") {
    Object.defineProperty(window, "AnimationEffect", {
      writable: true,
      configurable: true,
      value: MockedAnimationEffect
    });
  }
}

// src/mocks/web-animations-api/KeyframeEffect.ts
function convertPropertyIndexedKeyframes(piKeyframes) {
  const keyframes = [];
  let done = false;
  let keyframeIndex = 0;
  while (!done) {
    let keyframe;
    for (const property in piKeyframes) {
      const values = piKeyframes[property];
      const propertyArray = Array.isArray(values) ? values : [values];
      if (!propertyArray) {
        continue;
      }
      const piKeyframe = propertyArray[keyframeIndex];
      if (typeof piKeyframe === "undefined" || piKeyframe === null) {
        continue;
      }
      if (!keyframe) {
        keyframe = {};
      }
      keyframe[property] = piKeyframe;
    }
    if (keyframe) {
      keyframeIndex++;
      keyframes.push(keyframe);
      continue;
    }
    done = true;
  }
  return keyframes;
}
var _keyframes, _validateKeyframes, validateKeyframes_fn;
var MockedKeyframeEffect = class extends MockedAnimationEffect {
  constructor(target, keyframes, options = {}) {
    super();
    __privateAdd(this, _validateKeyframes);
    this.composite = "replace";
    this.pseudoElement = null;
    __privateAdd(this, _keyframes, []);
    if (typeof options === "number") {
      options = { duration: options };
    }
    const { composite, iterationComposite, pseudoElement, ...timing } = options;
    this.setKeyframes(keyframes);
    this.target = target;
    this.composite = composite || "replace";
    this.iterationComposite = iterationComposite || "replace";
    this.pseudoElement = pseudoElement || null;
    this.updateTiming(timing);
  }
  getKeyframes() {
    var _a;
    const totalKeyframes = __privateGet(this, _keyframes).length;
    if (totalKeyframes === 0) {
      return [];
    }
    let currentOffset = ((_a = __privateGet(this, _keyframes)[0]) == null ? void 0 : _a.offset) ?? (totalKeyframes === 1 ? 1 : 0);
    return __privateGet(this, _keyframes).map(({ composite, offset, easing, ...keyframe }, index) => {
      const computedKeyframe = {
        offset: offset ?? null,
        composite: composite ?? this.composite,
        easing: easing ?? "linear",
        computedOffset: currentOffset,
        ...keyframe
      };
      let nextOffset;
      let keyframesUntilNextOffset;
      for (let i = index + 1; i < totalKeyframes; i++) {
        const offset2 = __privateGet(this, _keyframes)[i].offset;
        if (typeof offset2 === "number") {
          nextOffset = offset2;
          keyframesUntilNextOffset = i - index;
          break;
        }
      }
      if (nextOffset === void 0) {
        nextOffset = 1;
        keyframesUntilNextOffset = __privateGet(this, _keyframes).length - index - 1;
      }
      const offsetDiff = typeof keyframesUntilNextOffset === "number" && keyframesUntilNextOffset > 0 ? (nextOffset - currentOffset) / keyframesUntilNextOffset : 0;
      currentOffset = currentOffset + offsetDiff;
      return computedKeyframe;
    });
  }
  setKeyframes(keyframes) {
    let kf;
    if (keyframes === null) {
      kf = [];
    } else if (Array.isArray(keyframes)) {
      kf = keyframes;
    } else {
      kf = convertPropertyIndexedKeyframes(keyframes);
    }
    __privateMethod(this, _validateKeyframes, validateKeyframes_fn).call(this, kf);
    __privateSet(this, _keyframes, kf);
  }
};
_keyframes = new WeakMap();
_validateKeyframes = new WeakSet();
validateKeyframes_fn = function(keyframes) {
  let lastExplicitOffset;
  keyframes.forEach((keyframe) => {
    const offset = keyframe.offset;
    if (typeof offset === "number") {
      if (offset < 0 || offset > 1) {
        throw new TypeError("Failed to construct 'KeyframeEffect': Offsets must be null or in the range [0,1].");
      }
      if (typeof lastExplicitOffset === "number") {
        if (offset < lastExplicitOffset) {
          throw new TypeError("Failed to construct 'KeyframeEffect': Offsets must be monotonically non-decreasing.");
        }
      }
      lastExplicitOffset = offset;
    }
  });
};
function mockKeyframeEffect() {
  mockAnimationEffect();
  if (typeof KeyframeEffect === "undefined") {
    Object.defineProperty(window, "KeyframeEffect", {
      writable: true,
      configurable: true,
      value: MockedKeyframeEffect
    });
  }
}

// src/mocks/web-animations-api/AnimationPlaybackEvent.ts
var MockedAnimationPlaybackEvent = class extends Event {
  constructor() {
    super(...arguments);
    this.currentTime = null;
    this.timelineTime = null;
  }
};
function mockAnimationPlaybackEvent() {
  if (typeof AnimationPlaybackEvent === "undefined") {
    Object.defineProperty(window, "AnimationPlaybackEvent", {
      writable: true,
      configurable: true,
      value: MockedAnimationPlaybackEvent
    });
  }
}

// src/mocks/web-animations-api/AnimationTimeline.ts
var MockedAnimationTimeline = class {
  constructor() {
    if (this.constructor === MockedAnimationTimeline) {
      throw new TypeError("Illegal constructor");
    }
  }
  get currentTime() {
    return performance.now();
  }
};
function mockAnimationTimeline() {
  if (typeof AnimationTimeline === "undefined") {
    Object.defineProperty(window, "AnimationTimeline", {
      writable: true,
      configurable: true,
      value: MockedAnimationTimeline
    });
  }
}

// src/mocks/web-animations-api/DocumentTimeline.ts
var _originTime;
var MockedDocumentTimeline = class extends MockedAnimationTimeline {
  constructor(options) {
    super();
    __privateAdd(this, _originTime, 0);
    __privateSet(this, _originTime, (options == null ? void 0 : options.originTime) ?? 0);
  }
  get currentTime() {
    return performance.now() - __privateGet(this, _originTime);
  }
};
_originTime = new WeakMap();
function mockDocumentTimeline() {
  mockAnimationTimeline();
  if (typeof DocumentTimeline === "undefined") {
    Object.defineProperty(window, "DocumentTimeline", {
      writable: true,
      configurable: true,
      value: MockedDocumentTimeline
    });
    Object.defineProperty(Document.prototype, "timeline", {
      writable: true,
      configurable: true,
      value: new MockedDocumentTimeline()
    });
  }
}

// src/mocks/web-animations-api/easingFunctions.ts
import BezierEasing from "bezier-easing";
var ease = BezierEasing(0.25, 0.1, 0.25, 1);
var easeIn = BezierEasing(0.42, 0, 1, 1);
var easeOut = BezierEasing(0, 0, 0.58, 1);
var easeInOut = BezierEasing(0.42, 0, 0.58, 1);
var easingFunctions = {
  linear: (value) => value,
  ease,
  "ease-in": easeIn,
  "ease-out": easeOut,
  "ease-in-out": easeInOut
};
function getEasingFunctionFromString(easing) {
  if (easingFunctions[easing]) {
    return easingFunctions[easing];
  }
  if (easing.indexOf("cubic-bezier(") === 0) {
    const bezierString = easing.replace("cubic-bezier(", "").replace(")", "");
    const bezierArray = bezierString.split(",").map(Number);
    easingFunctions[easing] = BezierEasing(bezierArray[0], bezierArray[1], bezierArray[2], bezierArray[3]);
    return easingFunctions[easing];
  }
  if (easing.indexOf("steps(") === 0) {
    throw new Error("steps() is not implemented yet");
  }
  throw new Error(`Unknown easing function "${easing}"`);
}

// src/mocks/web-animations-api/Animation.ts
var NON_STYLE_KEYFRAME_PROPERTIES = ["offset", "composite", "easing"];
var RENAMED_KEYFRAME_PROPERTIES = {
  cssFloat: "float",
  cssOffset: "offset"
};
var noop = () => {
};
var _finishedPromise, _readyPromise, _startTime, _pendingPauseTask, _pendingPlayTask, _previousCurrentTime, _previousPhase, _effect, _timeline, _rafId, _initialKeyframe, _fillMode, _promiseStates, _resolvers, _getRawComputedTiming, _pendingPlaybackRate, _playbackRate, _holdTime, _getTiming, getTiming_fn, _getComputedTiming, getComputedTiming_fn, _localTime, localTime_get, _getNewFinishedPromise, getNewFinishedPromise_fn, _getNewReadyPromise, getNewReadyPromise_fn, _silentlyRejectFinishedPromise, silentlyRejectFinishedPromise_fn, _hasPendingTask, hasPendingTask_fn, _isTimelineActive, isTimelineActive_fn, _hasKeyframeEffect, hasKeyframeEffect_fn, _isTimelineMonotonicallyIncreasing, isTimelineMonotonicallyIncreasing_fn, _calcInitialKeyframe, calcInitialKeyframe_fn, _applyPendingPlaybackRate, applyPendingPlaybackRate_fn, _animationDirection, animationDirection_get, _phase, phase_get, _resetPendingTasks, resetPendingTasks_fn, _calculateCurrentTime, calculateCurrentTime_fn, _calculateStartTime, calculateStartTime_fn, _getCurrentTimeInternal, getCurrentTimeInternal_fn, _effectivePlaybackRate, effectivePlaybackRate_get, _setCurrentTimeSilent, setCurrentTimeSilent_fn, _iteration, iteration_fn, _cancelIteration, cancelIteration_fn, _playTask, playTask_fn, _play, play_fn, _pauseTask, pauseTask_fn, _finishNotification, finishNotification_fn, _queuedFinishNotificationMicrotask, _cancelFinishNotificationMicrotask, cancelFinishNotificationMicrotask_fn, _queueFinishNotificationMicrotask, queueFinishNotificationMicrotask_fn, _updateFinishedState, updateFinishedState_fn, _activeTime, activeTime_get, _overallProgress, overallProgress_get, _iterationProgress, iterationProgress_get, _currentIteration, currentIteration_get, _currentDirection, currentDirection_get, _directedProgress, directedProgress_get, _transformedProgress, transformedProgress_get, _commitKeyframeStyles, commitKeyframeStyles_fn;
var MockedAnimation = class extends EventTarget {
  constructor(effect = null, timeline = document.timeline) {
    super();
    __privateAdd(this, _getTiming);
    __privateAdd(this, _getComputedTiming);
    __privateAdd(this, _localTime);
    __privateAdd(this, _getNewFinishedPromise);
    __privateAdd(this, _getNewReadyPromise);
    __privateAdd(this, _silentlyRejectFinishedPromise);
    __privateAdd(this, _hasPendingTask);
    __privateAdd(this, _isTimelineActive);
    __privateAdd(this, _hasKeyframeEffect);
    __privateAdd(this, _isTimelineMonotonicallyIncreasing);
    __privateAdd(this, _calcInitialKeyframe);
    __privateAdd(this, _applyPendingPlaybackRate);
    __privateAdd(this, _animationDirection);
    __privateAdd(this, _phase);
    __privateAdd(this, _resetPendingTasks);
    __privateAdd(this, _calculateCurrentTime);
    __privateAdd(this, _calculateStartTime);
    __privateAdd(this, _getCurrentTimeInternal);
    __privateAdd(this, _effectivePlaybackRate);
    __privateAdd(this, _setCurrentTimeSilent);
    __privateAdd(this, _iteration);
    __privateAdd(this, _cancelIteration);
    __privateAdd(this, _playTask);
    __privateAdd(this, _play);
    __privateAdd(this, _pauseTask);
    __privateAdd(this, _finishNotification);
    __privateAdd(this, _cancelFinishNotificationMicrotask);
    __privateAdd(this, _queueFinishNotificationMicrotask);
    __privateAdd(this, _updateFinishedState);
    __privateAdd(this, _activeTime);
    __privateAdd(this, _overallProgress);
    __privateAdd(this, _iterationProgress);
    __privateAdd(this, _currentIteration);
    __privateAdd(this, _currentDirection);
    __privateAdd(this, _directedProgress);
    __privateAdd(this, _transformedProgress);
    __privateAdd(this, _commitKeyframeStyles);
    this.id = "";
    this.pending = false;
    this.replaceState = "active";
    __privateAdd(this, _finishedPromise, void 0);
    __privateAdd(this, _readyPromise, void 0);
    __privateAdd(this, _startTime, null);
    __privateAdd(this, _pendingPauseTask, null);
    __privateAdd(this, _pendingPlayTask, null);
    __privateAdd(this, _previousCurrentTime, null);
    __privateAdd(this, _previousPhase, "idle");
    __privateAdd(this, _effect, null);
    __privateAdd(this, _timeline, null);
    __privateAdd(this, _rafId, null);
    __privateAdd(this, _initialKeyframe, void 0);
    __privateAdd(this, _fillMode, void 0);
    __privateAdd(this, _promiseStates, {
      finished: "pending",
      ready: "resolved"
    });
    __privateAdd(this, _resolvers, {
      ready: {
        resolve: noop,
        reject: noop
      },
      finished: {
        resolve: noop,
        reject: noop
      }
    });
    __privateAdd(this, _getRawComputedTiming, () => ({}));
    __privateAdd(this, _pendingPlaybackRate, null);
    __privateAdd(this, _playbackRate, 1);
    __privateAdd(this, _holdTime, null);
    __privateAdd(this, _queuedFinishNotificationMicrotask, null);
    this.oncancel = null;
    this.onfinish = null;
    this.onremove = null;
    this.effect = effect;
    __privateSet(this, _timeline, timeline);
    __privateSet(this, _initialKeyframe, __privateMethod(this, _calcInitialKeyframe, calcInitialKeyframe_fn).call(this));
    __privateSet(this, _fillMode, (effect == null ? void 0 : effect.getComputedTiming().fill) ?? "none");
    __privateSet(this, _finishedPromise, __privateMethod(this, _getNewFinishedPromise, getNewFinishedPromise_fn).call(this));
    __privateSet(this, _readyPromise, Promise.resolve(this));
  }
  get animationEffectStateInPlay() {
    return __privateGet(this, _phase, phase_get) === "active" && this.playState !== "finished";
  }
  get animationEffectStateCurrent() {
    const phase = __privateGet(this, _phase, phase_get);
    return this.animationEffectStateInPlay || this.playbackRate > 0 && phase === "before" || this.playbackRate < 0 && phase === "after";
  }
  get animationEffectStateInEffect() {
    return __privateGet(this, _activeTime, activeTime_get) !== null;
  }
  get finished() {
    return __privateGet(this, _finishedPromise);
  }
  get ready() {
    return __privateGet(this, _readyPromise);
  }
  get timeline() {
    return __privateGet(this, _timeline);
  }
  set timeline(timeline) {
    if (__privateGet(this, _timeline) === timeline) {
      return;
    }
    __privateSet(this, _timeline, timeline);
    if (this.startTime !== null) {
      __privateSet(this, _holdTime, null);
    }
    __privateMethod(this, _updateFinishedState, updateFinishedState_fn).call(this, false, false);
  }
  get effect() {
    return __privateGet(this, _effect);
  }
  set effect(effect) {
    const oldEffect = __privateGet(this, _effect);
    if (effect === oldEffect) {
      return;
    }
    if (__privateGet(this, _pendingPauseTask)) {
      this.ready.then(() => {
        var _a;
        return (_a = __privateGet(this, _pendingPauseTask)) == null ? void 0 : _a.call(this);
      });
    }
    if (__privateGet(this, _pendingPlayTask)) {
      this.ready.then(() => {
        var _a;
        return (_a = __privateGet(this, _pendingPlayTask)) == null ? void 0 : _a.call(this);
      });
    }
    if (effect) {
      const anotherAnimation = document.getAnimations().find((anim) => anim.effect === effect);
      if (anotherAnimation) {
        anotherAnimation.effect = null;
      }
    }
    __privateSet(this, _effect, effect);
    __privateMethod(this, _updateFinishedState, updateFinishedState_fn).call(this, false, false);
    if (effect) {
      __privateSet(this, _getRawComputedTiming, effect.getComputedTiming);
      effect.getComputedTiming = () => {
        const computedTiming = __privateGet(this, _getRawComputedTiming).call(effect);
        return {
          ...computedTiming,
          localTime: __privateGet(this, _localTime, localTime_get),
          progress: __privateGet(this, _transformedProgress, transformedProgress_get)
        };
      };
    }
  }
  get currentTime() {
    return __privateMethod(this, _getCurrentTimeInternal, getCurrentTimeInternal_fn).call(this);
  }
  set currentTime(seekTime) {
    __privateMethod(this, _setCurrentTimeSilent, setCurrentTimeSilent_fn).call(this, seekTime);
    if (__privateGet(this, _pendingPauseTask)) {
      __privateSet(this, _holdTime, seekTime);
      __privateMethod(this, _applyPendingPlaybackRate, applyPendingPlaybackRate_fn).call(this);
      __privateSet(this, _startTime, null);
      __privateSet(this, _pendingPauseTask, null);
      __privateGet(this, _resolvers).ready.resolve(this);
    }
    __privateMethod(this, _updateFinishedState, updateFinishedState_fn).call(this, true, false);
  }
  get startTime() {
    return __privateGet(this, _startTime);
  }
  set startTime(newTime) {
    var _a;
    const timelineTime = ((_a = __privateGet(this, _timeline)) == null ? void 0 : _a.currentTime) ?? null;
    if (timelineTime === null && newTime !== null) {
      __privateSet(this, _holdTime, null);
    }
    __privateSet(this, _previousCurrentTime, this.currentTime);
    __privateMethod(this, _applyPendingPlaybackRate, applyPendingPlaybackRate_fn).call(this);
    __privateSet(this, _startTime, newTime);
    if (newTime !== null) {
      if (this.playbackRate !== 0) {
        __privateSet(this, _holdTime, null);
      }
    } else {
      __privateSet(this, _holdTime, __privateGet(this, _previousCurrentTime));
    }
    if (__privateMethod(this, _hasPendingTask, hasPendingTask_fn).call(this)) {
      __privateSet(this, _pendingPlayTask, null);
      __privateSet(this, _pendingPauseTask, null);
      __privateGet(this, _resolvers).ready.resolve(this);
    }
    __privateMethod(this, _updateFinishedState, updateFinishedState_fn).call(this, true, false);
  }
  play() {
    __privateMethod(this, _play, play_fn).call(this, true);
  }
  pause() {
    if (__privateGet(this, _pendingPauseTask) !== null) {
      return;
    }
    if (this.playState === "paused") {
      return;
    }
    let seekTime = null;
    const hasFiniteTimeline = __privateGet(this, _timeline) && !__privateMethod(this, _isTimelineMonotonicallyIncreasing, isTimelineMonotonicallyIncreasing_fn).call(this);
    const currentTime = this.currentTime;
    const effectEnd = __privateMethod(this, _getComputedTiming, getComputedTiming_fn).call(this).endTime;
    if (currentTime === null) {
      if (__privateGet(this, _playbackRate) >= 0) {
        seekTime = 0;
      } else {
        if (effectEnd === Infinity) {
          throw new DOMException("Failed to execute 'pause' on 'Animation': Cannot play reversed Animation with infinite target effect end.", "InvalidStateError");
        } else {
          seekTime = effectEnd;
        }
      }
    }
    if (seekTime !== null) {
      if (hasFiniteTimeline) {
        this.startTime = seekTime;
      } else {
        __privateSet(this, _holdTime, seekTime);
      }
    }
    let hasPendingReadyPromise = false;
    if (__privateGet(this, _pendingPlayTask) !== null) {
      __privateSet(this, _pendingPlayTask, null);
      hasPendingReadyPromise = true;
    }
    if (!hasPendingReadyPromise) {
      __privateSet(this, _readyPromise, __privateMethod(this, _getNewReadyPromise, getNewReadyPromise_fn).call(this));
    }
    __privateSet(this, _pendingPauseTask, () => {
      __privateMethod(this, _pauseTask, pauseTask_fn).call(this);
    });
    queueMicrotask(() => {
      var _a;
      (_a = __privateGet(this, _pendingPauseTask)) == null ? void 0 : _a.call(this);
      __privateMethod(this, _updateFinishedState, updateFinishedState_fn).call(this, false, false);
    });
    __privateMethod(this, _cancelIteration, cancelIteration_fn).call(this);
  }
  finish() {
    const effectivePlaybackRate = __privateGet(this, _effectivePlaybackRate, effectivePlaybackRate_get);
    const effectEnd = __privateMethod(this, _getComputedTiming, getComputedTiming_fn).call(this).endTime;
    if (effectivePlaybackRate === 0 || effectivePlaybackRate > 0 && effectEnd === Infinity) {
      throw new DOMException("Failed to execute 'finish' on 'Animation': Cannot finish Animation with an infinite target effect end.", "InvalidStateError");
    }
    __privateMethod(this, _applyPendingPlaybackRate, applyPendingPlaybackRate_fn).call(this);
    const limit = __privateGet(this, _playbackRate) > 0 ? effectEnd : 0;
    __privateMethod(this, _setCurrentTimeSilent, setCurrentTimeSilent_fn).call(this, limit);
    if (__privateGet(this, _startTime) === null && __privateMethod(this, _isTimelineActive, isTimelineActive_fn).call(this)) {
      __privateSet(this, _startTime, this.timeline.currentTime - limit / __privateGet(this, _playbackRate));
    }
    if (__privateGet(this, _pendingPauseTask) !== null && __privateGet(this, _startTime) !== null) {
      __privateSet(this, _holdTime, null);
      __privateSet(this, _pendingPauseTask, null);
      __privateGet(this, _resolvers).ready.resolve(this);
    }
    if (__privateGet(this, _pendingPlayTask) !== null && __privateGet(this, _startTime) !== null) {
      __privateSet(this, _pendingPlayTask, null);
      __privateGet(this, _resolvers).ready.resolve(this);
    }
    __privateMethod(this, _updateFinishedState, updateFinishedState_fn).call(this, true, true);
  }
  cancel() {
    var _a, _b;
    if (!__privateMethod(this, _hasKeyframeEffect, hasKeyframeEffect_fn).call(this)) {
      return;
    }
    if (this.playState !== "idle") {
      __privateMethod(this, _resetPendingTasks, resetPendingTasks_fn).call(this);
      __privateMethod(this, _silentlyRejectFinishedPromise, silentlyRejectFinishedPromise_fn).call(this, new DOMException("The user aborted a request.", "AbortError"));
      __privateSet(this, _finishedPromise, __privateMethod(this, _getNewFinishedPromise, getNewFinishedPromise_fn).call(this));
      const timelineTime = ((_a = this.timeline) == null ? void 0 : _a.currentTime) ?? null;
      const cancelEvent = new AnimationPlaybackEvent("cancel", {
        currentTime: null,
        timelineTime
      });
      this.dispatchEvent(cancelEvent);
      (_b = this.oncancel) == null ? void 0 : _b.call(this, cancelEvent);
    } else {
      __privateSet(this, _pendingPlaybackRate, null);
      __privateSet(this, _pendingPauseTask, __privateSet(this, _pendingPlayTask, null));
    }
    __privateSet(this, _holdTime, null);
    __privateSet(this, _startTime, null);
  }
  get playbackRate() {
    return __privateGet(this, _playbackRate);
  }
  set playbackRate(rate) {
    __privateSet(this, _pendingPlaybackRate, null);
    const previousTime = this.currentTime;
    __privateSet(this, _playbackRate, rate);
    if (previousTime !== null) {
      this.currentTime = previousTime;
    }
  }
  updatePlaybackRate(playbackRate) {
    var _a;
    const previousPlayState = this.playState;
    __privateSet(this, _pendingPlaybackRate, playbackRate);
    if (__privateMethod(this, _hasPendingTask, hasPendingTask_fn).call(this)) {
      return;
    }
    switch (previousPlayState) {
      case "idle":
      case "paused":
        __privateMethod(this, _applyPendingPlaybackRate, applyPendingPlaybackRate_fn).call(this);
        break;
      case "finished":
        {
          const unconstrainedCurrentTime = __privateMethod(this, _calculateCurrentTime, calculateCurrentTime_fn).call(this) ?? __privateGet(this, _holdTime);
          const timelineTime = ((_a = this.timeline) == null ? void 0 : _a.currentTime) ?? null;
          if (__privateGet(this, _pendingPlaybackRate) !== 0) {
            if (timelineTime) {
              __privateSet(this, _startTime, unconstrainedCurrentTime ? timelineTime - unconstrainedCurrentTime / __privateGet(this, _pendingPlaybackRate) : null);
            }
          } else {
            __privateSet(this, _startTime, timelineTime);
          }
          __privateMethod(this, _applyPendingPlaybackRate, applyPendingPlaybackRate_fn).call(this);
          __privateMethod(this, _updateFinishedState, updateFinishedState_fn).call(this, false, false);
        }
        break;
      case "running":
        __privateMethod(this, _cancelIteration, cancelIteration_fn).call(this);
        __privateMethod(this, _play, play_fn).call(this, false);
        break;
    }
  }
  reverse() {
    if (this.timeline === null || !__privateMethod(this, _isTimelineActive, isTimelineActive_fn).call(this)) {
      throw new DOMException("Cannot reverse an animation with no active timeline", "InvalidStateError");
    }
    const originalPendingPlaybackRate = __privateGet(this, _pendingPlaybackRate);
    __privateSet(this, _pendingPlaybackRate, -__privateGet(this, _effectivePlaybackRate, effectivePlaybackRate_get));
    __privateMethod(this, _cancelIteration, cancelIteration_fn).call(this);
    try {
      __privateMethod(this, _play, play_fn).call(this, true);
    } catch (error) {
      __privateSet(this, _pendingPlaybackRate, originalPendingPlaybackRate);
      throw error;
    }
  }
  get playState() {
    const currentTime = this.currentTime;
    if (currentTime === null && __privateGet(this, _startTime) === null && !__privateMethod(this, _hasPendingTask, hasPendingTask_fn).call(this)) {
      return "idle";
    } else if (__privateGet(this, _pendingPauseTask) !== null || this.startTime === null && __privateGet(this, _pendingPlayTask) === null) {
      return "paused";
    } else if (currentTime !== null && (__privateGet(this, _effectivePlaybackRate, effectivePlaybackRate_get) > 0 && currentTime >= __privateMethod(this, _getComputedTiming, getComputedTiming_fn).call(this).endTime || __privateGet(this, _effectivePlaybackRate, effectivePlaybackRate_get) < 0 && currentTime <= 0)) {
      return "finished";
    } else {
      return "running";
    }
  }
  set playState(_newPlayState) {
    throw new TypeError("Cannot set property playState of #<Animation> which has only a getter");
  }
  commitStyles() {
    if (!(__privateGet(this, _effect) instanceof KeyframeEffect) || !__privateMethod(this, _isTimelineActive, isTimelineActive_fn).call(this)) {
      return;
    }
    const keyframes = __privateGet(this, _effect).getKeyframes();
    const currentProgress = __privateGet(this, _transformedProgress, transformedProgress_get);
    const currentDirection = __privateGet(this, _currentDirection, currentDirection_get);
    if (keyframes.length === 0 || currentProgress === null || currentDirection === null || !__privateGet(this, _effect).target) {
      return;
    }
    if (keyframes.length === 1 && (currentDirection === "forwards" && currentProgress <= 0.5 || currentDirection === "reverse" && currentProgress >= 0.5)) {
      __privateMethod(this, _commitKeyframeStyles, commitKeyframeStyles_fn).call(this, __privateGet(this, _initialKeyframe));
      return;
    }
    let closestKeyframe = keyframes[0];
    let smallestDistance = Infinity;
    for (const keyframe of keyframes) {
      const distance = Math.abs(keyframe.computedOffset - currentProgress);
      if (distance < smallestDistance) {
        smallestDistance = distance;
        closestKeyframe = keyframe;
      }
    }
    __privateMethod(this, _commitKeyframeStyles, commitKeyframeStyles_fn).call(this, closestKeyframe);
  }
  persist() {
    console.log("persist isn't implemented yet");
  }
};
_finishedPromise = new WeakMap();
_readyPromise = new WeakMap();
_startTime = new WeakMap();
_pendingPauseTask = new WeakMap();
_pendingPlayTask = new WeakMap();
_previousCurrentTime = new WeakMap();
_previousPhase = new WeakMap();
_effect = new WeakMap();
_timeline = new WeakMap();
_rafId = new WeakMap();
_initialKeyframe = new WeakMap();
_fillMode = new WeakMap();
_promiseStates = new WeakMap();
_resolvers = new WeakMap();
_getRawComputedTiming = new WeakMap();
_pendingPlaybackRate = new WeakMap();
_playbackRate = new WeakMap();
_holdTime = new WeakMap();
_getTiming = new WeakSet();
getTiming_fn = function() {
  return __privateGet(this, _effect).getTiming();
};
_getComputedTiming = new WeakSet();
getComputedTiming_fn = function() {
  return __privateGet(this, _getRawComputedTiming).call(this.effect);
};
_localTime = new WeakSet();
localTime_get = function() {
  if (__privateGet(this, _effect) !== null) {
    return this.currentTime;
  }
  return null;
};
_getNewFinishedPromise = new WeakSet();
getNewFinishedPromise_fn = function() {
  __privateGet(this, _promiseStates).finished = "pending";
  return new Promise((resolve, reject) => {
    __privateGet(this, _resolvers).finished.resolve = (animation) => {
      __privateGet(this, _promiseStates).finished = "resolved";
      resolve(animation);
    };
    __privateGet(this, _resolvers).finished.reject = (error) => {
      __privateGet(this, _promiseStates).finished = "rejected";
      reject(error);
    };
  });
};
_getNewReadyPromise = new WeakSet();
getNewReadyPromise_fn = function() {
  __privateGet(this, _promiseStates).ready = "pending";
  return new Promise((resolve, reject) => {
    __privateGet(this, _resolvers).ready.resolve = (animation) => {
      __privateGet(this, _promiseStates).ready = "resolved";
      resolve(animation);
    };
    __privateGet(this, _resolvers).ready.reject = (error) => {
      __privateGet(this, _promiseStates).ready = "rejected";
      reject(error);
    };
  });
};
_silentlyRejectFinishedPromise = new WeakSet();
silentlyRejectFinishedPromise_fn = function(error) {
  __privateGet(this, _finishedPromise).catch(noop);
  __privateGet(this, _resolvers).finished.reject(error);
};
_hasPendingTask = new WeakSet();
hasPendingTask_fn = function() {
  return __privateGet(this, _pendingPauseTask) || __privateGet(this, _pendingPlayTask);
};
_isTimelineActive = new WeakSet();
isTimelineActive_fn = function() {
  var _a;
  return ((_a = __privateGet(this, _timeline)) == null ? void 0 : _a.currentTime) !== null;
};
_hasKeyframeEffect = new WeakSet();
hasKeyframeEffect_fn = function() {
  return __privateGet(this, _effect) instanceof KeyframeEffect;
};
_isTimelineMonotonicallyIncreasing = new WeakSet();
isTimelineMonotonicallyIncreasing_fn = function() {
  return __privateGet(this, _timeline) instanceof DocumentTimeline;
};
_calcInitialKeyframe = new WeakSet();
calcInitialKeyframe_fn = function() {
  const initialKeyframe = {};
  const uniqueProps = /* @__PURE__ */ new Set();
  if (!(__privateGet(this, _effect) instanceof KeyframeEffect)) {
    return initialKeyframe;
  }
  const target = __privateGet(this, _effect).target;
  __privateGet(this, _effect).getKeyframes().forEach((keyframe) => {
    for (const property in keyframe) {
      if (NON_STYLE_KEYFRAME_PROPERTIES.includes(property)) {
        continue;
      }
      uniqueProps.add(property);
    }
  });
  uniqueProps.forEach((property) => {
    const propertyName = RENAMED_KEYFRAME_PROPERTIES[property] ?? property;
    const value = target.style.getPropertyValue(propertyName);
    initialKeyframe[property] = value;
  });
  return initialKeyframe;
};
_applyPendingPlaybackRate = new WeakSet();
applyPendingPlaybackRate_fn = function() {
  if (__privateGet(this, _pendingPlaybackRate) !== null) {
    __privateSet(this, _playbackRate, __privateGet(this, _pendingPlaybackRate));
    __privateSet(this, _pendingPlaybackRate, null);
  }
};
_animationDirection = new WeakSet();
animationDirection_get = function() {
  return __privateGet(this, _effect) !== null && this.playbackRate < 0 ? "backwards" : "forwards";
};
_phase = new WeakSet();
phase_get = function() {
  const localTime = __privateGet(this, _localTime, localTime_get);
  if (localTime === null) {
    return "idle";
  }
  const { delay, activeDuration, endTime } = __privateMethod(this, _getComputedTiming, getComputedTiming_fn).call(this);
  const beforeActiveBoundaryTime = Math.max(Math.min(delay, endTime), 0);
  const activeAfterBoundaryTime = Math.max(Math.min(delay + activeDuration, endTime), 0);
  if (localTime < beforeActiveBoundaryTime || __privateGet(this, _animationDirection, animationDirection_get) === "backwards" && localTime === beforeActiveBoundaryTime) {
    return "before";
  }
  if (localTime > activeAfterBoundaryTime || __privateGet(this, _animationDirection, animationDirection_get) === "forwards" && localTime === activeAfterBoundaryTime) {
    return "after";
  }
  return "active";
};
_resetPendingTasks = new WeakSet();
resetPendingTasks_fn = function() {
  if (!__privateMethod(this, _hasPendingTask, hasPendingTask_fn).call(this)) {
    return;
  }
  if (__privateGet(this, _pendingPlayTask)) {
    __privateSet(this, _pendingPlayTask, null);
  }
  if (__privateGet(this, _pendingPauseTask)) {
    __privateSet(this, _pendingPauseTask, null);
  }
  __privateMethod(this, _applyPendingPlaybackRate, applyPendingPlaybackRate_fn).call(this);
  __privateMethod(this, _silentlyRejectFinishedPromise, silentlyRejectFinishedPromise_fn).call(this, new DOMException(void 0, "AbortError"));
  __privateSet(this, _readyPromise, Promise.resolve(this));
};
_calculateCurrentTime = new WeakSet();
calculateCurrentTime_fn = function() {
  if (!__privateGet(this, _timeline) || __privateGet(this, _timeline).currentTime === null || this.startTime === null) {
    return null;
  } else {
    return (__privateGet(this, _timeline).currentTime - this.startTime) * this.playbackRate;
  }
};
_calculateStartTime = new WeakSet();
calculateStartTime_fn = function(seekTime) {
  let startTime = null;
  if (__privateGet(this, _timeline)) {
    const timelineTime = __privateGet(this, _timeline).currentTime;
    if (timelineTime !== null) {
      startTime = timelineTime - seekTime / this.playbackRate;
    }
  }
  return startTime;
};
_getCurrentTimeInternal = new WeakSet();
getCurrentTimeInternal_fn = function() {
  return __privateGet(this, _holdTime) !== null ? __privateGet(this, _holdTime) : __privateMethod(this, _calculateCurrentTime, calculateCurrentTime_fn).call(this);
};
_effectivePlaybackRate = new WeakSet();
effectivePlaybackRate_get = function() {
  return __privateGet(this, _pendingPlaybackRate) ?? this.playbackRate;
};
_setCurrentTimeSilent = new WeakSet();
setCurrentTimeSilent_fn = function(seekTime) {
  if (seekTime === null) {
    if (this.currentTime !== null) {
      throw new TypeError("Failed to set the 'currentTime' property on 'Animation': currentTime may not be changed from resolved to unresolved");
    }
    return;
  }
  const startTime = this.startTime;
  const holdTime = __privateGet(this, _holdTime);
  if (holdTime || startTime === null || __privateGet(this, _timeline) === null || __privateGet(this, _timeline).currentTime === null || this.playbackRate == 0) {
    __privateSet(this, _holdTime, seekTime);
  } else {
    this.startTime = __privateMethod(this, _calculateStartTime, calculateStartTime_fn).call(this, seekTime);
  }
  __privateSet(this, _previousCurrentTime, null);
};
_iteration = new WeakSet();
iteration_fn = function() {
  if (!__privateMethod(this, _hasKeyframeEffect, hasKeyframeEffect_fn).call(this)) {
    return;
  }
  const playState = this.playState;
  const phase = __privateGet(this, _phase, phase_get);
  const fillMode = __privateGet(this, _fillMode);
  const keyframes = this.effect.getKeyframes();
  if (playState === "running" || playState === "finished") {
    if (__privateGet(this, _previousPhase) !== phase) {
      if (__privateGet(this, _previousPhase) === "idle") {
        if (this.playbackRate > 0) {
          if (phase === "before" && (fillMode === "backwards" || fillMode === "both")) {
            if (keyframes.length > 1) {
              __privateMethod(this, _commitKeyframeStyles, commitKeyframeStyles_fn).call(this, keyframes[0]);
            }
          }
        } else {
          if (phase === "after" && (fillMode === "forwards" || fillMode === "both")) {
            __privateMethod(this, _commitKeyframeStyles, commitKeyframeStyles_fn).call(this, keyframes[keyframes.length - 1]);
          }
        }
      } else if (__privateGet(this, _previousPhase) === "active") {
        if (phase === "after") {
          if (fillMode === "backwards" || fillMode === "none") {
            __privateMethod(this, _commitKeyframeStyles, commitKeyframeStyles_fn).call(this, __privateGet(this, _initialKeyframe));
          }
        } else if (phase === "before") {
          if (fillMode === "forwards" || fillMode === "none") {
            __privateMethod(this, _commitKeyframeStyles, commitKeyframeStyles_fn).call(this, __privateGet(this, _initialKeyframe));
          }
        }
      }
    }
    if (phase === "active") {
      this.commitStyles();
    }
    if (playState === "running") {
      __privateSet(this, _rafId, requestAnimationFrame(() => {
        __privateMethod(this, _iteration, iteration_fn).call(this);
      }));
    }
    __privateSet(this, _previousPhase, phase);
  }
  __privateMethod(this, _updateFinishedState, updateFinishedState_fn).call(this, false, true);
};
_cancelIteration = new WeakSet();
cancelIteration_fn = function() {
  if (__privateGet(this, _rafId) !== null) {
    cancelAnimationFrame(__privateGet(this, _rafId));
    __privateSet(this, _rafId, null);
  }
};
_playTask = new WeakSet();
playTask_fn = function() {
  __privateSet(this, _pendingPlayTask, null);
  if (!__privateMethod(this, _isTimelineActive, isTimelineActive_fn).call(this)) {
    throw new Error("Failed to play an 'Animation': the animation's timeline is inactive");
  }
  if (__privateGet(this, _startTime) === null && __privateGet(this, _holdTime) === null) {
    throw new Error("Failed to play an 'Animation': the start time or hold time must be resolved");
  }
  const readyTime = this.timeline.currentTime;
  if (__privateGet(this, _holdTime) !== null) {
    __privateMethod(this, _applyPendingPlaybackRate, applyPendingPlaybackRate_fn).call(this);
    const newStartTime = __privateGet(this, _playbackRate) === 0 ? readyTime : readyTime - __privateGet(this, _holdTime) / __privateGet(this, _playbackRate);
    this.startTime = newStartTime;
  } else if (__privateGet(this, _startTime) !== null && __privateGet(this, _pendingPlaybackRate) !== null) {
    const currentTimeToMatch = (readyTime - __privateGet(this, _startTime)) * this.playbackRate;
    __privateMethod(this, _applyPendingPlaybackRate, applyPendingPlaybackRate_fn).call(this);
    if (__privateGet(this, _playbackRate) === 0) {
      __privateSet(this, _holdTime, currentTimeToMatch);
    } else {
      const newStartTime = readyTime - currentTimeToMatch / __privateGet(this, _playbackRate);
      this.startTime = newStartTime;
    }
  }
  __privateGet(this, _resolvers).ready.resolve(this);
  __privateMethod(this, _updateFinishedState, updateFinishedState_fn).call(this, false, false);
};
_play = new WeakSet();
play_fn = function(autoRewind) {
  const abortedPause = __privateGet(this, _pendingPauseTask) !== null;
  let hasPendingReadyPromise = false;
  let seekTime = null;
  const hasFiniteTimeline = __privateGet(this, _timeline) && !__privateMethod(this, _isTimelineMonotonicallyIncreasing, isTimelineMonotonicallyIncreasing_fn).call(this);
  const currentTime = this.currentTime;
  const effectEnd = __privateMethod(this, _getComputedTiming, getComputedTiming_fn).call(this).endTime;
  if (__privateGet(this, _effectivePlaybackRate, effectivePlaybackRate_get) > 0 && autoRewind && (currentTime === null || currentTime < 0 || currentTime >= effectEnd)) {
    seekTime = 0;
  } else if (__privateGet(this, _effectivePlaybackRate, effectivePlaybackRate_get) < 0 && autoRewind && (currentTime === null || currentTime <= 0 || currentTime > effectEnd)) {
    if (effectEnd === Infinity) {
      throw new DOMException("Failed to execute 'play' on 'Animation': Cannot play reversed Animation with infinite target effect end.", "InvalidStateError");
    }
    seekTime = effectEnd;
  } else if (__privateGet(this, _effectivePlaybackRate, effectivePlaybackRate_get) === 0 && currentTime === null) {
    seekTime = 0;
  }
  if (seekTime !== null) {
    if (hasFiniteTimeline) {
      this.startTime = seekTime;
      __privateSet(this, _holdTime, null);
      __privateMethod(this, _applyPendingPlaybackRate, applyPendingPlaybackRate_fn).call(this);
    } else {
      __privateSet(this, _holdTime, seekTime);
    }
  }
  if (__privateGet(this, _holdTime) !== null) {
    this.startTime = null;
  }
  if (__privateMethod(this, _hasPendingTask, hasPendingTask_fn).call(this)) {
    __privateSet(this, _pendingPauseTask, null);
    __privateSet(this, _pendingPlayTask, null);
    hasPendingReadyPromise = true;
  }
  if (__privateGet(this, _holdTime) === null && seekTime === null && !abortedPause && __privateGet(this, _pendingPlaybackRate) === null) {
    return;
  }
  if (!hasPendingReadyPromise) {
    __privateSet(this, _readyPromise, __privateMethod(this, _getNewReadyPromise, getNewReadyPromise_fn).call(this));
  }
  __privateSet(this, _pendingPlayTask, () => {
    __privateMethod(this, _playTask, playTask_fn).call(this);
  });
  this.ready.then(() => {
    var _a;
    (_a = __privateGet(this, _pendingPlayTask)) == null ? void 0 : _a.call(this);
    __privateMethod(this, _iteration, iteration_fn).call(this);
  });
  queueMicrotask(() => {
    __privateGet(this, _resolvers).ready.resolve(this);
  });
  __privateMethod(this, _updateFinishedState, updateFinishedState_fn).call(this, false, false);
};
_pauseTask = new WeakSet();
pauseTask_fn = function() {
  __privateSet(this, _pendingPauseTask, null);
  if (!__privateMethod(this, _isTimelineActive, isTimelineActive_fn).call(this)) {
    throw new Error("Failed to pause an 'Animation': the animation's timeline is inactive");
  }
  const readyTime = this.timeline.currentTime;
  if (__privateGet(this, _startTime) !== null && __privateGet(this, _holdTime) === null) {
    __privateSet(this, _holdTime, (readyTime - __privateGet(this, _startTime)) * __privateGet(this, _playbackRate));
  }
  __privateMethod(this, _applyPendingPlaybackRate, applyPendingPlaybackRate_fn).call(this);
  __privateSet(this, _startTime, null);
  __privateGet(this, _resolvers).ready.resolve(this);
  __privateMethod(this, _updateFinishedState, updateFinishedState_fn).call(this, false, false);
};
_finishNotification = new WeakSet();
finishNotification_fn = function() {
  var _a;
  if (this.playState !== "finished") {
    return;
  }
  __privateGet(this, _resolvers).finished.resolve(this);
  const finishEvent = new AnimationPlaybackEvent("finish", {
    currentTime: this.currentTime,
    timelineTime: this.timeline ? this.timeline.currentTime : null
  });
  this.dispatchEvent(finishEvent);
  (_a = this.onfinish) == null ? void 0 : _a.call(this, finishEvent);
};
_queuedFinishNotificationMicrotask = new WeakMap();
_cancelFinishNotificationMicrotask = new WeakSet();
cancelFinishNotificationMicrotask_fn = function() {
  __privateSet(this, _queuedFinishNotificationMicrotask, null);
};
_queueFinishNotificationMicrotask = new WeakSet();
queueFinishNotificationMicrotask_fn = function() {
  if (__privateGet(this, _queuedFinishNotificationMicrotask) === null) {
    __privateSet(this, _queuedFinishNotificationMicrotask, () => {
      __privateMethod(this, _finishNotification, finishNotification_fn).call(this);
      __privateSet(this, _queuedFinishNotificationMicrotask, null);
    });
    queueMicrotask(() => {
      var _a;
      return (_a = __privateGet(this, _queuedFinishNotificationMicrotask)) == null ? void 0 : _a.call(this);
    });
  }
};
_updateFinishedState = new WeakSet();
updateFinishedState_fn = function(didSeek, synchronouslyNotify) {
  const unconstrainedCurrentTime = didSeek ? __privateMethod(this, _calculateCurrentTime, calculateCurrentTime_fn).call(this) : this.currentTime;
  const startTime = this.startTime;
  const effectEnd = __privateMethod(this, _getComputedTiming, getComputedTiming_fn).call(this).endTime;
  if (unconstrainedCurrentTime !== null && startTime !== null && !__privateMethod(this, _hasPendingTask, hasPendingTask_fn).call(this)) {
    const playbackRate = this.playbackRate;
    if (playbackRate > 0 && unconstrainedCurrentTime >= effectEnd) {
      if (didSeek) {
        __privateSet(this, _holdTime, unconstrainedCurrentTime);
      } else {
        if (__privateGet(this, _previousCurrentTime) === null) {
          __privateSet(this, _holdTime, effectEnd);
        } else {
          __privateSet(this, _holdTime, Math.max(__privateGet(this, _previousCurrentTime), effectEnd));
        }
      }
    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {
      if (didSeek) {
        __privateSet(this, _holdTime, unconstrainedCurrentTime);
      } else {
        if (__privateGet(this, _previousCurrentTime) === null) {
          __privateSet(this, _holdTime, 0);
        } else {
          __privateSet(this, _holdTime, Math.min(__privateGet(this, _previousCurrentTime), 0));
        }
      }
    } else if (playbackRate !== 0 && __privateMethod(this, _isTimelineActive, isTimelineActive_fn).call(this)) {
      if (didSeek && __privateGet(this, _holdTime) !== null) {
        this.startTime = this.timeline.currentTime - __privateGet(this, _holdTime) / playbackRate;
      }
      __privateSet(this, _holdTime, null);
    }
  }
  __privateSet(this, _previousCurrentTime, __privateMethod(this, _calculateCurrentTime, calculateCurrentTime_fn).call(this));
  const currentFinishedState = this.playState === "finished";
  if (currentFinishedState && __privateGet(this, _promiseStates).finished !== "resolved") {
    if (synchronouslyNotify) {
      __privateMethod(this, _cancelFinishNotificationMicrotask, cancelFinishNotificationMicrotask_fn).call(this);
      __privateMethod(this, _finishNotification, finishNotification_fn).call(this);
    } else {
      __privateMethod(this, _queueFinishNotificationMicrotask, queueFinishNotificationMicrotask_fn).call(this);
    }
  }
  if (!currentFinishedState && __privateGet(this, _promiseStates).finished === "resolved") {
    __privateSet(this, _finishedPromise, __privateMethod(this, _getNewFinishedPromise, getNewFinishedPromise_fn).call(this));
  }
};
_activeTime = new WeakSet();
activeTime_get = function() {
  const computedTiming = __privateMethod(this, _getComputedTiming, getComputedTiming_fn).call(this);
  const localTime = __privateGet(this, _localTime, localTime_get);
  if (localTime === null) {
    return null;
  }
  switch (__privateGet(this, _phase, phase_get)) {
    case "before":
      if (__privateGet(this, _fillMode) === "backwards" || __privateGet(this, _fillMode) === "both") {
        return Math.max(localTime - computedTiming.delay, 0);
      } else {
        return null;
      }
    case "active":
      return localTime - computedTiming.delay;
    case "after":
      if (__privateGet(this, _fillMode) === "forwards" || __privateGet(this, _fillMode) === "both") {
        return Math.max(Math.min(localTime - computedTiming.delay, computedTiming.activeDuration), 0);
      } else {
        return null;
      }
    default:
      return null;
  }
};
_overallProgress = new WeakSet();
overallProgress_get = function() {
  const activeTime = __privateGet(this, _activeTime, activeTime_get);
  if (activeTime === null) {
    return null;
  }
  const computedTiming = __privateMethod(this, _getComputedTiming, getComputedTiming_fn).call(this);
  let overallProgress;
  if (computedTiming.duration === 0) {
    if (__privateGet(this, _phase, phase_get) === "before") {
      overallProgress = 0;
    } else {
      overallProgress = computedTiming.iterations;
    }
  } else {
    overallProgress = activeTime / computedTiming.duration;
  }
  return overallProgress + computedTiming.iterationStart;
};
_iterationProgress = new WeakSet();
iterationProgress_get = function() {
  const overallProgress = __privateGet(this, _overallProgress, overallProgress_get);
  if (overallProgress === null) {
    return null;
  }
  const computedTiming = __privateMethod(this, _getComputedTiming, getComputedTiming_fn).call(this);
  let iterationProgress;
  if (overallProgress === Infinity) {
    iterationProgress = computedTiming.iterationStart % 1;
  } else {
    iterationProgress = overallProgress % 1;
  }
  if (iterationProgress === 0 && (__privateGet(this, _phase, phase_get) === "active" || __privateGet(this, _phase, phase_get) === "after") && __privateGet(this, _activeTime, activeTime_get) === computedTiming.activeDuration && computedTiming.iterations !== 0) {
    iterationProgress = 1;
  }
  return iterationProgress;
};
_currentIteration = new WeakSet();
currentIteration_get = function() {
  const activeTime = __privateGet(this, _activeTime, activeTime_get);
  if (activeTime === null) {
    return null;
  }
  const timing = __privateMethod(this, _getTiming, getTiming_fn).call(this);
  if (__privateGet(this, _phase, phase_get) === "after" && timing.iterations === Infinity) {
    return Infinity;
  }
  const iterationProgress = __privateGet(this, _iterationProgress, iterationProgress_get);
  const overallProgress = __privateGet(this, _overallProgress, overallProgress_get);
  if (iterationProgress === 1) {
    return Math.floor(overallProgress) - 1;
  } else {
    return Math.floor(overallProgress);
  }
};
_currentDirection = new WeakSet();
currentDirection_get = function() {
  if (__privateGet(this, _currentIteration, currentIteration_get) === null) {
    return null;
  }
  const timing = __privateMethod(this, _getTiming, getTiming_fn).call(this);
  let currentDirection;
  const playbackDirection = timing.direction;
  if (playbackDirection === "normal") {
    currentDirection = "forwards";
  } else if (playbackDirection === "reverse") {
    currentDirection = "reverse";
  } else {
    let currentIteration = __privateGet(this, _currentIteration, currentIteration_get);
    if (playbackDirection === "alternate-reverse") {
      currentIteration += 1;
    }
    if (currentIteration === Infinity || currentIteration % 2 === 0) {
      currentDirection = "forwards";
    } else {
      currentDirection = "reverse";
    }
  }
  return currentDirection;
};
_directedProgress = new WeakSet();
directedProgress_get = function() {
  const iterationProgress = __privateGet(this, _iterationProgress, iterationProgress_get);
  if (iterationProgress === null) {
    return null;
  }
  const currentDirection = __privateGet(this, _currentDirection, currentDirection_get);
  if (currentDirection === "forwards") {
    return iterationProgress;
  } else {
    return 1 - iterationProgress;
  }
};
_transformedProgress = new WeakSet();
transformedProgress_get = function() {
  const directedProgress = __privateGet(this, _directedProgress, directedProgress_get);
  const timing = __privateMethod(this, _getTiming, getTiming_fn).call(this);
  if (directedProgress === null || typeof timing === "undefined") {
    return null;
  }
  const timingFunction = getEasingFunctionFromString(timing.easing);
  const currentDirection = directedProgress >= 0 ? "forwards" : "reverse";
  const beforeFlag = __privateGet(this, _phase, phase_get) === "before" && currentDirection === "forwards" || __privateGet(this, _phase, phase_get) === "after" && currentDirection === "reverse";
  return timingFunction(directedProgress, beforeFlag);
};
_commitKeyframeStyles = new WeakSet();
commitKeyframeStyles_fn = function(keyframe) {
  if (!(__privateGet(this, _effect) instanceof KeyframeEffect)) {
    return;
  }
  const element = __privateGet(this, _effect).target;
  const { composite, computedOffset, easing, offset, ...keyframeStyles } = keyframe;
  for (const property in keyframeStyles) {
    const value = keyframeStyles[property];
    if (typeof value === "undefined" || value === null) {
      element.style.removeProperty(property);
      continue;
    }
    const valueAsString = typeof value === "string" ? value : value.toString();
    element.style.setProperty(property, valueAsString);
  }
};
function mockAnimation() {
  mockKeyframeEffect();
  mockAnimationPlaybackEvent();
  mockDocumentTimeline();
  if (typeof Animation === "undefined") {
    Object.defineProperty(window, "Animation", {
      writable: true,
      configurable: true,
      value: MockedAnimation
    });
  }
}

// src/mocks/web-animations-api/index.ts
var elementAnimations = /* @__PURE__ */ new Map();
function animate(keyframes, options) {
  const keyframeEffect = new KeyframeEffect(this, keyframes, options);
  const animation = new Animation(keyframeEffect);
  const animations = elementAnimations.get(this) ?? [];
  animations.push(animation);
  elementAnimations.set(this, animations);
  animation.addEventListener("finish", () => {
    const animations2 = elementAnimations.get(this);
    if (animations2) {
      const index = animations2.indexOf(animation);
      if (index !== -1) {
        animations2.splice(index, 1);
      }
    }
  });
  animation.play();
  return animation;
}
function getAnimations() {
  return elementAnimations.get(this) ?? [];
}
function getAllAnimations() {
  return Array.from(elementAnimations.values()).flat();
}
function mockAnimationsApi() {
  const savedAnimate = Element.prototype.animate;
  const savedGetAnimations = Element.prototype.getAnimations;
  const savedGetAllAnimations = Document.prototype.getAnimations;
  mockAnimation();
  Object.defineProperties(Element.prototype, {
    animate: {
      writable: true,
      configurable: true,
      value: animate
    },
    getAnimations: {
      writable: true,
      configurable: true,
      value: getAnimations
    }
  });
  Object.defineProperty(Document.prototype, "getAnimations", {
    writable: true,
    configurable: true,
    value: getAllAnimations
  });
  afterEach(() => {
    elementAnimations.clear();
  });
  afterAll(() => {
    Element.prototype.animate = savedAnimate;
    Element.prototype.getAnimations = savedGetAnimations;
    Document.prototype.getAnimations = savedGetAllAnimations;
  });
}
export {
  MockedDOMRect,
  MockedIntersectionObserver,
  mockAnimationsApi,
  mockElementBoundingClientRect,
  mockIntersectionObserver,
  mockResizeObserver,
  mockViewport,
  mockViewportForTestGroup
};
//# sourceMappingURL=index.js.map