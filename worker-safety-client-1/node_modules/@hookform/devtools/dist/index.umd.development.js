(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-hook-form')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-hook-form'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactHookFormDevTools = {}, global.React, global.ReactHookForm));
}(this, (function (exports, React, reactHookForm) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
    var React__namespace = /*#__PURE__*/_interopNamespace(React);

    var a=new(function(){function e(e){void 0===e&&(e="__LSM__"),this.name=e,this.state={},this.middleWares=[];try{this.storageType="undefined"!=typeof sessionStorage?window.sessionStorage:{};}catch(e){this.storageType={};}}var t=e.prototype;return t.updateStore=function(e){this.state=function(e,t){try{return JSON.parse(e.getItem(t))}catch(e){return null}}(this.storageType,this.name)||e;},t.updateMiddleWares=function(e){return this.middleWares=e},e}()),i=React.createContext(void 0),s=function(e){var r=e.children,o=React.useState(a.state);return React.createElement(i.Provider,{value:{state:o[0],setState:o[1]}},r)};function _(e,t){var n,r,o;void 0===t&&(t={name:"__LSM__",middleWares:[]}),t.name&&(a.name=t.name),t.storageType&&(a.storageType=t.storageType),t.middleWares&&a.updateMiddleWares(t.middleWares),(n=a.storageType,r=a.name,o=a.state,"undefined"!=typeof window&&(window.__LSM__=r,window.__LSM_NAME__=r,window.__LSM_DEBUG__=function(e){return n.setItem("___LSM_DEBUG__",e)},window.__LSM_RESET__=function(){return n.removeItem(r)},window.__LSM_GET_STORE__=function(){return n.getItem(r)},window.__LSM_SAVE_TO__=function(e){return window.localStorage.setItem(e,JSON.stringify(o))},window.__LSM_LOAD__=function(e){return n.setItem(r||"___LSM_DEBUG__",e.data||window.localStorage.getItem(e.storeName)||"")})),a.updateStore(e);}function d(e){var t,n=(t=React.useContext(i),(t||console.error("StateMachine context is undefined, please verify you are calling useStateMachine() as child of a <StateMachineProvider> component.")),t),s=n.state,_=n.setState;return React.useMemo(function(){return {actions:e?Object.entries(e).reduce(function(e,t){var n;return Object.assign({},e,((n={})[t[0]]=function(e,t){return function(n){(window.__LSM_NAME__=t?t.name:""),a.state=t(a.state,n),a.storageType.setItem(a.name,JSON.stringify(a.state)),a.middleWares.length&&(a.state=a.middleWares.reduce(function(e,r){return r(e,t.name,n)||e},a.state)),e(a.state);}}(_,t[1]),n))},{}):{},state:s}},[s,_,e])}

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }

    var isUndefined$1 = (val) => val === undefined;

    function getSequenceId(sequenceIndex, sequenceId, defaultValue) {
        if (isUndefined$1(sequenceId) && isUndefined$1(sequenceIndex)) {
            return defaultValue || 0;
        }
        if (sequenceIndex && sequenceIndex >= 0) {
            return sequenceIndex;
        }
        if (sequenceId) {
            return sequenceId;
        }
        return 0;
    }

    const DEFAULT_DURATION = 0.3;
    const DEFAULT_EASE_TYPE = 'linear';
    const ALL = 'all';

    const AnimateContext = React__default['default'].createContext({
        animationStates: {},
        register: (data) => { },
    });

    var secToMs = (ms) => (ms || 0) * 1000;

    function Animate(props) {
        const { play, children, render, start, end, complete = '', onComplete, delay = 0, duration = DEFAULT_DURATION, easeType = DEFAULT_EASE_TYPE, sequenceId, sequenceIndex, } = props;
        const onCompleteTimeRef = React__default['default'].useRef();
        const [style, setStyle] = React__default['default'].useState(start || {});
        const { register, animationStates = {} } = React__default['default'].useContext(AnimateContext);
        const id = getSequenceId(sequenceIndex, sequenceId);
        React__default['default'].useEffect(() => {
            if ((!isUndefined$1(sequenceIndex) && sequenceIndex >= 0) || sequenceId) {
                register(props);
            }
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);
        React__default['default'].useEffect(() => {
            const animationState = animationStates[id] || {};
            setStyle(Object.assign(Object.assign({}, (play || animationState.play ? end : start)), { transition: `${ALL} ${duration}s ${easeType} ${parseFloat(animationState.delay || delay)}s` }));
            if (play && (complete || onComplete)) {
                onCompleteTimeRef.current = setTimeout(() => {
                    complete && setStyle(complete);
                    onComplete && onComplete();
                }, secToMs(parseFloat(animationState.delay || delay) + duration));
            }
            return () => onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);
        }, [
            id,
            animationStates,
            play,
            duration,
            easeType,
            delay,
            onComplete,
            start,
            end,
            complete,
        ]);
        return render ? render({ style }) : React__default['default'].createElement("div", { style: style }, children);
    }

    var Animate_1 = Animate;

    var colors = {
        primary: '#0e101c',
        secondary: '#bf1650',
        lightBlue: '#516391',
        blue: '#1e2a4a',
        lightPink: '#ec5990',
        errorPink: '#fbecf2',
        buttonBlue: '#191d3a',
        link: '#ff7aa8',
        green: '#1bda2b',
    };

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    function memoize(fn) {
      var cache = Object.create(null);
      return function (arg) {
        if (cache[arg] === undefined) cache[arg] = fn(arg);
        return cache[arg];
      };
    }

    var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

    var isPropValid = /* #__PURE__ */memoize(function (prop) {
      return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
      /* o */
      && prop.charCodeAt(1) === 110
      /* n */
      && prop.charCodeAt(2) < 91;
    }
    /* Z+1 */
    );

    /*

    Based off glamor's StyleSheet, thanks Sunil ❤️

    high performance StyleSheet for css-in-js systems

    - uses multiple style tags behind the scenes for millions of rules
    - uses `insertRule` for appending in production for *much* faster performance

    // usage

    import { StyleSheet } from '@emotion/sheet'

    let styleSheet = new StyleSheet({ key: '', container: document.head })

    styleSheet.insert('#box { border: 1px solid red; }')
    - appends a css rule into the stylesheet

    styleSheet.flush()
    - empties the stylesheet of all its contents

    */
    // $FlowFixMe
    function sheetForTag(tag) {
      if (tag.sheet) {
        // $FlowFixMe
        return tag.sheet;
      } // this weirdness brought to you by firefox

      /* istanbul ignore next */


      for (var i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].ownerNode === tag) {
          // $FlowFixMe
          return document.styleSheets[i];
        }
      }
    }

    function createStyleElement(options) {
      var tag = document.createElement('style');
      tag.setAttribute('data-emotion', options.key);

      if (options.nonce !== undefined) {
        tag.setAttribute('nonce', options.nonce);
      }

      tag.appendChild(document.createTextNode(''));
      tag.setAttribute('data-s', '');
      return tag;
    }

    var StyleSheet = /*#__PURE__*/function () {
      function StyleSheet(options) {
        var _this = this;

        this._insertTag = function (tag) {
          var before;

          if (_this.tags.length === 0) {
            before = _this.prepend ? _this.container.firstChild : _this.before;
          } else {
            before = _this.tags[_this.tags.length - 1].nextSibling;
          }

          _this.container.insertBefore(tag, before);

          _this.tags.push(tag);
        };

        this.isSpeedy = options.speedy === undefined ? "development" === 'production' : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.before = null;
      }

      var _proto = StyleSheet.prototype;

      _proto.hydrate = function hydrate(nodes) {
        nodes.forEach(this._insertTag);
      };

      _proto.insert = function insert(rule) {
        // the max length is how many rules we have per style tag, it's 65000 in speedy mode
        // it's 1 in dev because we insert source maps that map a single rule to a location
        // and you can only have one source map per style tag
        if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
          this._insertTag(createStyleElement(this));
        }

        var tag = this.tags[this.tags.length - 1];

        {
          var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;

          if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
            // this would only cause problem in speedy mode
            // but we don't want enabling speedy to affect the observable behavior
            // so we report this error at all times
            console.error("You're attempting to insert the following rule:\n" + rule + '\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.');
          }
          this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
        }

        if (this.isSpeedy) {
          var sheet = sheetForTag(tag);

          try {
            // this is the ultrafast version, works across browsers
            // the big drawback is that the css won't be editable in devtools
            sheet.insertRule(rule, sheet.cssRules.length);
          } catch (e) {
            if (!/:(-moz-placeholder|-ms-input-placeholder|-moz-read-write|-moz-read-only){/.test(rule)) {
              console.error("There was a problem inserting the following rule: \"" + rule + "\"", e);
            }
          }
        } else {
          tag.appendChild(document.createTextNode(rule));
        }

        this.ctr++;
      };

      _proto.flush = function flush() {
        // $FlowFixMe
        this.tags.forEach(function (tag) {
          return tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;

        {
          this._alreadyInsertedOrderInsensitiveRule = false;
        }
      };

      return StyleSheet;
    }();

    var MS = '-ms-';
    var MOZ = '-moz-';
    var WEBKIT = '-webkit-';

    var COMMENT = 'comm';
    var RULESET = 'rule';
    var DECLARATION = 'decl';
    var IMPORT = '@import';
    var KEYFRAMES = '@keyframes';

    /**
     * @param {number}
     * @return {number}
     */
    var abs = Math.abs;

    /**
     * @param {number}
     * @return {string}
     */
    var from = String.fromCharCode;

    /**
     * @param {string} value
     * @param {number} length
     * @return {number}
     */
    function hash (value, length) {
    	return (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3)
    }

    /**
     * @param {string} value
     * @return {string}
     */
    function trim (value) {
    	return value.trim()
    }

    /**
     * @param {string} value
     * @param {RegExp} pattern
     * @return {string?}
     */
    function match (value, pattern) {
    	return (value = pattern.exec(value)) ? value[0] : value
    }

    /**
     * @param {string} value
     * @param {(string|RegExp)} pattern
     * @param {string} replacement
     * @return {string}
     */
    function replace (value, pattern, replacement) {
    	return value.replace(pattern, replacement)
    }

    /**
     * @param {string} value
     * @param {string} value
     * @return {number}
     */
    function indexof (value, search) {
    	return value.indexOf(search)
    }

    /**
     * @param {string} value
     * @param {number} index
     * @return {number}
     */
    function charat (value, index) {
    	return value.charCodeAt(index) | 0
    }

    /**
     * @param {string} value
     * @param {number} begin
     * @param {number} end
     * @return {string}
     */
    function substr (value, begin, end) {
    	return value.slice(begin, end)
    }

    /**
     * @param {string} value
     * @return {number}
     */
    function strlen (value) {
    	return value.length
    }

    /**
     * @param {any[]} value
     * @return {number}
     */
    function sizeof (value) {
    	return value.length
    }

    /**
     * @param {any} value
     * @param {any[]} array
     * @return {any}
     */
    function append (value, array) {
    	return array.push(value), value
    }

    /**
     * @param {string[]} array
     * @param {function} callback
     * @return {string}
     */
    function combine (array, callback) {
    	return array.map(callback).join('')
    }

    var line = 1;
    var column = 1;
    var length = 0;
    var position = 0;
    var character = 0;
    var characters = '';

    /**
     * @param {string} value
     * @param {object} root
     * @param {object?} parent
     * @param {string} type
     * @param {string[]} props
     * @param {object[]} children
     * @param {number} length
     */
    function node (value, root, parent, type, props, children, length) {
    	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
    }

    /**
     * @param {string} value
     * @param {object} root
     * @param {string} type
     */
    function copy (value, root, type) {
    	return node(value, root.root, root.parent, type, root.props, root.children, 0)
    }

    /**
     * @return {number}
     */
    function char () {
    	return character
    }

    /**
     * @return {number}
     */
    function prev () {
    	character = position > 0 ? charat(characters, --position) : 0;

    	if (column--, character === 10)
    		column = 1, line--;

    	return character
    }

    /**
     * @return {number}
     */
    function next () {
    	character = position < length ? charat(characters, position++) : 0;

    	if (column++, character === 10)
    		column = 1, line++;

    	return character
    }

    /**
     * @return {number}
     */
    function peek () {
    	return charat(characters, position)
    }

    /**
     * @return {number}
     */
    function caret () {
    	return position
    }

    /**
     * @param {number} begin
     * @param {number} end
     * @return {string}
     */
    function slice (begin, end) {
    	return substr(characters, begin, end)
    }

    /**
     * @param {number} type
     * @return {number}
     */
    function token (type) {
    	switch (type) {
    		// \0 \t \n \r \s whitespace token
    		case 0: case 9: case 10: case 13: case 32:
    			return 5
    		// ! + , / > @ ~ isolate token
    		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
    		// ; { } breakpoint token
    		case 59: case 123: case 125:
    			return 4
    		// : accompanied token
    		case 58:
    			return 3
    		// " ' ( [ opening delimit token
    		case 34: case 39: case 40: case 91:
    			return 2
    		// ) ] closing delimit token
    		case 41: case 93:
    			return 1
    	}

    	return 0
    }

    /**
     * @param {string} value
     * @return {any[]}
     */
    function alloc (value) {
    	return line = column = 1, length = strlen(characters = value), position = 0, []
    }

    /**
     * @param {any} value
     * @return {any}
     */
    function dealloc (value) {
    	return characters = '', value
    }

    /**
     * @param {number} type
     * @return {string}
     */
    function delimit (type) {
    	return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
    }

    /**
     * @param {number} type
     * @return {string}
     */
    function whitespace (type) {
    	while (character = peek())
    		if (character < 33)
    			next();
    		else
    			break

    	return token(type) > 2 || token(character) > 3 ? '' : ' '
    }

    /**
     * @param {number} index
     * @param {number} count
     * @return {string}
     */
    function escaping (index, count) {
    	while (--count && next())
    		// not 0-9 A-F a-f
    		if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
    			break

    	return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
    }

    /**
     * @param {number} type
     * @return {number}
     */
    function delimiter (type) {
    	while (next())
    		switch (character) {
    			// ] ) " '
    			case type:
    				return position
    			// " '
    			case 34: case 39:
    				return delimiter(type === 34 || type === 39 ? type : character)
    			// (
    			case 40:
    				if (type === 41)
    					delimiter(type);
    				break
    			// \
    			case 92:
    				next();
    				break
    		}

    	return position
    }

    /**
     * @param {number} type
     * @param {number} index
     * @return {number}
     */
    function commenter (type, index) {
    	while (next())
    		// //
    		if (type + character === 47 + 10)
    			break
    		// /*
    		else if (type + character === 42 + 42 && peek() === 47)
    			break

    	return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next())
    }

    /**
     * @param {number} index
     * @return {string}
     */
    function identifier (index) {
    	while (!token(peek()))
    		next();

    	return slice(index, position)
    }

    /**
     * @param {string} value
     * @return {object[]}
     */
    function compile (value) {
    	return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value))
    }

    /**
     * @param {string} value
     * @param {object} root
     * @param {object?} parent
     * @param {string[]} rule
     * @param {string[]} rules
     * @param {string[]} rulesets
     * @param {number[]} pseudo
     * @param {number[]} points
     * @param {string[]} declarations
     * @return {object}
     */
    function parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
    	var index = 0;
    	var offset = 0;
    	var length = pseudo;
    	var atrule = 0;
    	var property = 0;
    	var previous = 0;
    	var variable = 1;
    	var scanning = 1;
    	var ampersand = 1;
    	var character = 0;
    	var type = '';
    	var props = rules;
    	var children = rulesets;
    	var reference = rule;
    	var characters = type;

    	while (scanning)
    		switch (previous = character, character = next()) {
    			// " ' [ (
    			case 34: case 39: case 91: case 40:
    				characters += delimit(character);
    				break
    			// \t \n \r \s
    			case 9: case 10: case 13: case 32:
    				characters += whitespace(previous);
    				break
    			// \
    			case 92:
    				characters += escaping(caret() - 1, 7);
    				continue
    			// /
    			case 47:
    				switch (peek()) {
    					case 42: case 47:
    						append(comment(commenter(next(), caret()), root, parent), declarations);
    						break
    					default:
    						characters += '/';
    				}
    				break
    			// {
    			case 123 * variable:
    				points[index++] = strlen(characters) * ampersand;
    			// } ; \0
    			case 125 * variable: case 59: case 0:
    				switch (character) {
    					// \0 }
    					case 0: case 125: scanning = 0;
    					// ;
    					case 59 + offset:
    						if (property > 0 && (strlen(characters) - length))
    							append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
    						break
    					// @ ;
    					case 59: characters += ';';
    					// { rule/at-rule
    					default:
    						append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);

    						if (character === 123)
    							if (offset === 0)
    								parse(characters, root, reference, reference, props, rulesets, length, points, children);
    							else
    								switch (atrule) {
    									// d m s
    									case 100: case 109: case 115:
    										parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
    										break
    									default:
    										parse(characters, reference, reference, reference, [''], children, length, points, children);
    								}
    				}

    				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
    				break
    			// :
    			case 58:
    				length = 1 + strlen(characters), property = previous;
    			default:
    				if (variable < 1)
    					if (character == 123)
    						--variable;
    					else if (character == 125 && variable++ == 0 && prev() == 125)
    						continue

    				switch (characters += from(character), character * variable) {
    					// &
    					case 38:
    						ampersand = offset > 0 ? 1 : (characters += '\f', -1);
    						break
    					// ,
    					case 44:
    						points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
    						break
    					// @
    					case 64:
    						// -
    						if (peek() === 45)
    							characters += delimit(next());

    						atrule = peek(), offset = strlen(type = characters += identifier(caret())), character++;
    						break
    					// -
    					case 45:
    						if (previous === 45 && strlen(characters) == 2)
    							variable = 0;
    				}
    		}

    	return rulesets
    }

    /**
     * @param {string} value
     * @param {object} root
     * @param {object?} parent
     * @param {number} index
     * @param {number} offset
     * @param {string[]} rules
     * @param {number[]} points
     * @param {string} type
     * @param {string[]} props
     * @param {string[]} children
     * @param {number} length
     * @return {object}
     */
    function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
    	var post = offset - 1;
    	var rule = offset === 0 ? rules : [''];
    	var size = sizeof(rule);

    	for (var i = 0, j = 0, k = 0; i < index; ++i)
    		for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
    			if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x])))
    				props[k++] = z;

    	return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length)
    }

    /**
     * @param {number} value
     * @param {object} root
     * @param {object?} parent
     * @return {object}
     */
    function comment (value, root, parent) {
    	return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0)
    }

    /**
     * @param {string} value
     * @param {object} root
     * @param {object?} parent
     * @param {number} length
     * @return {object}
     */
    function declaration (value, root, parent, length) {
    	return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length)
    }

    /**
     * @param {string} value
     * @param {number} length
     * @return {string}
     */
    function prefix (value, length) {
    	switch (hash(value, length)) {
    		// color-adjust
    		case 5103:
    			return WEBKIT + 'print-' + value + value
    		// animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    		case 5737: case 4201: case 3177: case 3433: case 1641: case 4457: case 2921:
    		// text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    		case 5572: case 6356: case 5844: case 3191: case 6645: case 3005:
    		// mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    		case 6391: case 5879: case 5623: case 6135: case 4599: case 4855:
    		// background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    		case 4215: case 6389: case 5109: case 5365: case 5621: case 3829:
    			return WEBKIT + value + value
    		// appearance, user-select, transform, hyphens, text-size-adjust
    		case 5349: case 4246: case 4810: case 6968: case 2756:
    			return WEBKIT + value + MOZ + value + MS + value + value
    		// flex, flex-direction
    		case 6828: case 4268:
    			return WEBKIT + value + MS + value + value
    		// order
    		case 6165:
    			return WEBKIT + value + MS + 'flex-' + value + value
    		// align-items
    		case 5187:
    			return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value
    		// align-self
    		case 5443:
    			return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value
    		// align-content
    		case 4675:
    			return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value
    		// flex-shrink
    		case 5548:
    			return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value
    		// flex-basis
    		case 5292:
    			return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value
    		// flex-grow
    		case 6060:
    			return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value
    		// transition
    		case 4554:
    			return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value
    		// cursor
    		case 6187:
    			return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value
    		// background, background-image
    		case 5495: case 3959:
    			return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1')
    		// justify-content
    		case 4968:
    			return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value
    		// (margin|padding)-inline-(start|end)
    		case 4095: case 3583: case 4068: case 2532:
    			return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value
    		// (min|max)?(width|height|inline-size|block-size)
    		case 8116: case 7059: case 5753: case 5535:
    		case 5445: case 5701: case 4933: case 4677:
    		case 5533: case 5789: case 5021: case 4765:
    			// stretch, max-content, min-content, fill-available
    			if (strlen(value) - 1 - length > 6)
    				switch (charat(value, length + 1)) {
    					// (m)ax-content, (m)in-content
    					case 109:
    						// -
    						if (charat(value, length + 4) !== 45)
    							break
    					// (f)ill-available, (f)it-content
    					case 102:
    						return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value
    					// (s)tretch
    					case 115:
    						return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value
    				}
    			break
    		// position: sticky
    		case 4949:
    			// (s)ticky?
    			if (charat(value, length + 1) !== 115)
    				break
    		// display: (flex|inline-flex)
    		case 6444:
    			switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
    				// stic(k)y
    				case 107:
    					return replace(value, ':', ':' + WEBKIT) + value
    				// (inline-)?fl(e)x
    				case 101:
    					return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value
    			}
    			break
    		// writing-mode
    		case 5936:
    			switch (charat(value, length + 11)) {
    				// vertical-l(r)
    				case 114:
    					return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value
    				// vertical-r(l)
    				case 108:
    					return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value
    				// horizontal(-)tb
    				case 45:
    					return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value
    			}

    			return WEBKIT + value + MS + value + value
    	}

    	return value
    }

    /**
     * @param {object[]} children
     * @param {function} callback
     * @return {string}
     */
    function serialize (children, callback) {
    	var output = '';
    	var length = sizeof(children);

    	for (var i = 0; i < length; i++)
    		output += callback(children[i], i, children, callback) || '';

    	return output
    }

    /**
     * @param {object} element
     * @param {number} index
     * @param {object[]} children
     * @param {function} callback
     * @return {string}
     */
    function stringify (element, index, children, callback) {
    	switch (element.type) {
    		case IMPORT: case DECLARATION: return element.return = element.return || element.value
    		case COMMENT: return ''
    		case RULESET: element.value = element.props.join(',');
    	}

    	return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
    }

    /**
     * @param {function[]} collection
     * @return {function}
     */
    function middleware (collection) {
    	var length = sizeof(collection);

    	return function (element, index, children, callback) {
    		var output = '';

    		for (var i = 0; i < length; i++)
    			output += collection[i](element, index, children, callback) || '';

    		return output
    	}
    }

    /**
     * @param {object} element
     * @param {number} index
     * @param {object[]} children
     * @param {function} callback
     */
    function prefixer (element, index, children, callback) {
    	if (!element.return)
    		switch (element.type) {
    			case DECLARATION: element.return = prefix(element.value, element.length);
    				break
    			case KEYFRAMES:
    				return serialize([copy(replace(element.value, '@', '@' + WEBKIT), element, '')], callback)
    			case RULESET:
    				if (element.length)
    					return combine(element.props, function (value) {
    						switch (match(value, /(::plac\w+|:read-\w+)/)) {
    							// :read-(only|write)
    							case ':read-only': case ':read-write':
    								return serialize([copy(replace(value, /:(read-\w+)/, ':' + MOZ + '$1'), element, '')], callback)
    							// :placeholder
    							case '::placeholder':
    								return serialize([
    									copy(replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1'), element, ''),
    									copy(replace(value, /:(plac\w+)/, ':' + MOZ + '$1'), element, ''),
    									copy(replace(value, /:(plac\w+)/, MS + 'input-$1'), element, '')
    								], callback)
    						}

    						return ''
    					})
    		}
    }

    var weakMemoize = function weakMemoize(func) {
      // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps
      var cache = new WeakMap();
      return function (arg) {
        if (cache.has(arg)) {
          // $FlowFixMe
          return cache.get(arg);
        }

        var ret = func(arg);
        cache.set(arg, ret);
        return ret;
      };
    };

    var last = function last(arr) {
      return arr.length ? arr[arr.length - 1] : null;
    };

    var toRules = function toRules(parsed, points) {
      // pretend we've started with a comma
      var index = -1;
      var character = 44;

      do {
        switch (token(character)) {
          case 0:
            // &\f
            if (character === 38 && peek() === 12) {
              // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
              // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
              // and when it should just concatenate the outer and inner selectors
              // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
              points[index] = 1;
            }

            parsed[index] += identifier(position - 1);
            break;

          case 2:
            parsed[index] += delimit(character);
            break;

          case 4:
            // comma
            if (character === 44) {
              // colon
              parsed[++index] = peek() === 58 ? '&\f' : '';
              points[index] = parsed[index].length;
              break;
            }

          // fallthrough

          default:
            parsed[index] += from(character);
        }
      } while (character = next());

      return parsed;
    };

    var getRules = function getRules(value, points) {
      return dealloc(toRules(alloc(value), points));
    }; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


    var fixedElements = /* #__PURE__ */new WeakMap();
    var compat = function compat(element) {
      if (element.type !== 'rule' || !element.parent || // .length indicates if this rule contains pseudo or not
      !element.length) {
        return;
      }

      var value = element.value,
          parent = element.parent;
      var isImplicitRule = element.column === parent.column && element.line === parent.line;

      while (parent.type !== 'rule') {
        parent = parent.parent;
        if (!parent) return;
      } // short-circuit for the simplest case


      if (element.props.length === 1 && value.charCodeAt(0) !== 58
      /* colon */
      && !fixedElements.get(parent)) {
        return;
      } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
      // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


      if (isImplicitRule) {
        return;
      }

      fixedElements.set(element, true);
      var points = [];
      var rules = getRules(value, points);
      var parentRules = parent.props;

      for (var i = 0, k = 0; i < rules.length; i++) {
        for (var j = 0; j < parentRules.length; j++, k++) {
          element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
        }
      }
    };
    var removeLabel = function removeLabel(element) {
      if (element.type === 'decl') {
        var value = element.value;

        if ( // charcode for l
        value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98) {
          // this ignores label
          element["return"] = '';
          element.value = '';
        }
      }
    };
    var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';

    var isIgnoringComment = function isIgnoringComment(element) {
      return !!element && element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
    };

    var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
      return function (element, index, children) {
        if (element.type !== 'rule') return;
        var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);

        if (unsafePseudoClasses && cache.compat !== true) {
          var prevElement = index > 0 ? children[index - 1] : null;

          if (prevElement && isIgnoringComment(last(prevElement.children))) {
            return;
          }

          unsafePseudoClasses.forEach(function (unsafePseudoClass) {
            console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
          });
        }
      };
    };

    var isImportRule = function isImportRule(element) {
      return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
    };

    var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
      for (var i = index - 1; i >= 0; i--) {
        if (!isImportRule(children[i])) {
          return true;
        }
      }

      return false;
    }; // use this to remove incorrect elements from further processing
    // so they don't get handed to the `sheet` (or anything else)
    // as that could potentially lead to additional logs which in turn could be overhelming to the user


    var nullifyElement = function nullifyElement(element) {
      element.type = '';
      element.value = '';
      element["return"] = '';
      element.children = '';
      element.props = '';
    };

    var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
      if (!isImportRule(element)) {
        return;
      }

      if (element.parent) {
        console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
        nullifyElement(element);
      } else if (isPrependedWithRegularRules(index, children)) {
        console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
        nullifyElement(element);
      }
    };

    var isBrowser$4 = typeof document !== 'undefined';
    var getServerStylisCache = isBrowser$4 ? undefined : weakMemoize(function () {
      return memoize(function () {
        var cache = {};
        return function (name) {
          return cache[name];
        };
      });
    });
    var defaultStylisPlugins = [prefixer];

    var createCache = function createCache(options) {
      var key = options.key;

      if (!key) {
        throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\n" + "If multiple caches share the same key they might \"fight\" for each other's style elements.");
      }

      if (isBrowser$4 && key === 'css') {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
        // document.head is a safe place to move them to

        Array.prototype.forEach.call(ssrStyles, function (node) {
          document.head.appendChild(node);
          node.setAttribute('data-s', '');
        });
      }

      var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

      {
        // $FlowFixMe
        if (/[^a-z-]/.test(key)) {
          throw new Error("Emotion key must only contain lower case alphabetical characters and - but \"" + key + "\" was passed");
        }
      }

      var inserted = {}; // $FlowFixMe

      var container;
      var nodesToHydrate = [];

      if (isBrowser$4) {
        container = options.container || document.head;
        Array.prototype.forEach.call(document.querySelectorAll("style[data-emotion]"), function (node) {
          var attrib = node.getAttribute("data-emotion").split(' ');

          if (attrib[0] !== key) {
            return;
          } // $FlowFixMe


          for (var i = 1; i < attrib.length; i++) {
            inserted[attrib[i]] = true;
          }

          nodesToHydrate.push(node);
        });
      }

      var _insert;

      var omnipresentPlugins = [compat, removeLabel];

      {
        omnipresentPlugins.push(createUnsafeSelectorsAlarm({
          get compat() {
            return cache.compat;
          }

        }), incorrectImportAlarm);
      }

      if (isBrowser$4) {
        var currentSheet;
        var finalizingPlugins = [stringify, function (element) {
          if (!element.root) {
            if (element["return"]) {
              currentSheet.insert(element["return"]);
            } else if (element.value && element.type !== COMMENT) {
              // insert empty rule in non-production environments
              // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet
              currentSheet.insert(element.value + "{}");
            }
          }
        } ];
        var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

        var stylis = function stylis(styles) {
          return serialize(compile(styles), serializer);
        };

        _insert = function insert(selector, serialized, sheet, shouldCache) {
          currentSheet = sheet;

          if (serialized.map !== undefined) {
            currentSheet = {
              insert: function insert(rule) {
                sheet.insert(rule + serialized.map);
              }
            };
          }

          stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

          if (shouldCache) {
            cache.inserted[serialized.name] = true;
          }
        };
      } else {
        var _finalizingPlugins = [stringify];

        var _serializer = middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));

        var _stylis = function _stylis(styles) {
          return serialize(compile(styles), _serializer);
        }; // $FlowFixMe


        var serverStylisCache = getServerStylisCache(stylisPlugins)(key);

        var getRules = function getRules(selector, serialized) {
          var name = serialized.name;

          if (serverStylisCache[name] === undefined) {
            serverStylisCache[name] = _stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
          }

          return serverStylisCache[name];
        };

        _insert = function _insert(selector, serialized, sheet, shouldCache) {
          var name = serialized.name;
          var rules = getRules(selector, serialized);

          if (cache.compat === undefined) {
            // in regular mode, we don't set the styles on the inserted cache
            // since we don't need to and that would be wasting memory
            // we return them so that they are rendered in a style tag
            if (shouldCache) {
              cache.inserted[name] = true;
            }

            if ( // using === development instead of !== production
            // because if people do ssr in tests, the source maps showing up would be annoying
            serialized.map !== undefined) {
              return rules + serialized.map;
            }

            return rules;
          } else {
            // in compat mode, we put the styles on the inserted cache so
            // that emotion-server can pull out the styles
            // except when we don't want to cache it which was in Global but now
            // is nowhere but we don't want to do a major right now
            // and just in case we're going to leave the case here
            // it's also not affecting client side bundle size
            // so it's really not a big deal
            if (shouldCache) {
              cache.inserted[name] = rules;
            } else {
              return rules;
            }
          }
        };
      }

      var cache = {
        key: key,
        sheet: new StyleSheet({
          key: key,
          container: container,
          nonce: options.nonce,
          speedy: options.speedy,
          prepend: options.prepend
        }),
        nonce: options.nonce,
        inserted: inserted,
        registered: {},
        insert: _insert
      };
      cache.sheet.hydrate(nodesToHydrate);
      return cache;
    };

    var isBrowser$3 = typeof document !== 'undefined';
    function getRegisteredStyles$1(registered, registeredStyles, classNames) {
      var rawClassName = '';
      classNames.split(' ').forEach(function (className) {
        if (registered[className] !== undefined) {
          registeredStyles.push(registered[className] + ";");
        } else {
          rawClassName += className + " ";
        }
      });
      return rawClassName;
    }
    var insertStyles$1 = function insertStyles(cache, serialized, isStringTag) {
      var className = cache.key + "-" + serialized.name;

      if ( // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser$3 === false && cache.compat !== undefined) && cache.registered[className] === undefined) {
        cache.registered[className] = serialized.styles;
      }

      if (cache.inserted[serialized.name] === undefined) {
        var stylesForSSR = '';
        var current = serialized;

        do {
          var maybeStyles = cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

          if (!isBrowser$3 && maybeStyles !== undefined) {
            stylesForSSR += maybeStyles;
          }

          current = current.next;
        } while (current !== undefined);

        if (!isBrowser$3 && stylesForSSR.length !== 0) {
          return stylesForSSR;
        }
      }
    };

    /* eslint-disable */
    // Inspired by https://github.com/garycourt/murmurhash-js
    // Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
    function murmur2(str) {
      // 'm' and 'r' are mixing constants generated offline.
      // They're not really 'magic', they just happen to work well.
      // const m = 0x5bd1e995;
      // const r = 24;
      // Initialize the hash
      var h = 0; // Mix 4 bytes at a time into the hash

      var k,
          i = 0,
          len = str.length;

      for (; len >= 4; ++i, len -= 4) {
        k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
        k =
        /* Math.imul(k, m): */
        (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
        k ^=
        /* k >>> r: */
        k >>> 24;
        h =
        /* Math.imul(k, m): */
        (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
        /* Math.imul(h, m): */
        (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
      } // Handle the last few bytes of the input array


      switch (len) {
        case 3:
          h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

        case 2:
          h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

        case 1:
          h ^= str.charCodeAt(i) & 0xff;
          h =
          /* Math.imul(h, m): */
          (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
      } // Do a few final mixes of the hash to ensure the last few
      // bytes are well-incorporated.


      h ^= h >>> 13;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
      return ((h ^ h >>> 15) >>> 0).toString(36);
    }

    var unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };

    var ILLEGAL_ESCAPE_SEQUENCE_ERROR$2 = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
    var UNDEFINED_AS_OBJECT_KEY_ERROR$1 = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
    var hyphenateRegex$1 = /[A-Z]|^ms/g;
    var animationRegex$1 = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

    var isCustomProperty$1 = function isCustomProperty(property) {
      return property.charCodeAt(1) === 45;
    };

    var isProcessableValue$1 = function isProcessableValue(value) {
      return value != null && typeof value !== 'boolean';
    };

    var processStyleName$1 = /* #__PURE__ */memoize(function (styleName) {
      return isCustomProperty$1(styleName) ? styleName : styleName.replace(hyphenateRegex$1, '-$&').toLowerCase();
    });

    var processStyleValue$1 = function processStyleValue(key, value) {
      switch (key) {
        case 'animation':
        case 'animationName':
          {
            if (typeof value === 'string') {
              return value.replace(animationRegex$1, function (match, p1, p2) {
                cursor$1 = {
                  name: p1,
                  styles: p2,
                  next: cursor$1
                };
                return p1;
              });
            }
          }
      }

      if (unitlessKeys[key] !== 1 && !isCustomProperty$1(key) && typeof value === 'number' && value !== 0) {
        return value + 'px';
      }

      return value;
    };

    {
      var contentValuePattern$1 = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
      var contentValues$1 = ['normal', 'none', 'initial', 'inherit', 'unset'];
      var oldProcessStyleValue$1 = processStyleValue$1;
      var msPattern$1 = /^-ms-/;
      var hyphenPattern$1 = /-(.)/g;
      var hyphenatedCache$1 = {};

      processStyleValue$1 = function processStyleValue(key, value) {
        if (key === 'content') {
          if (typeof value !== 'string' || contentValues$1.indexOf(value) === -1 && !contentValuePattern$1.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
            throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
          }
        }

        var processed = oldProcessStyleValue$1(key, value);

        if (processed !== '' && !isCustomProperty$1(key) && key.indexOf('-') !== -1 && hyphenatedCache$1[key] === undefined) {
          hyphenatedCache$1[key] = true;
          console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern$1, 'ms-').replace(hyphenPattern$1, function (str, _char) {
            return _char.toUpperCase();
          }) + "?");
        }

        return processed;
      };
    }

    function handleInterpolation$1(mergedProps, registered, interpolation) {
      if (interpolation == null) {
        return '';
      }

      if (interpolation.__emotion_styles !== undefined) {
        if (interpolation.toString() === 'NO_COMPONENT_SELECTOR') {
          throw new Error('Component selectors can only be used in conjunction with @emotion/babel-plugin.');
        }

        return interpolation;
      }

      switch (typeof interpolation) {
        case 'boolean':
          {
            return '';
          }

        case 'object':
          {
            if (interpolation.anim === 1) {
              cursor$1 = {
                name: interpolation.name,
                styles: interpolation.styles,
                next: cursor$1
              };
              return interpolation.name;
            }

            if (interpolation.styles !== undefined) {
              var next = interpolation.next;

              if (next !== undefined) {
                // not the most efficient thing ever but this is a pretty rare case
                // and there will be very few iterations of this generally
                while (next !== undefined) {
                  cursor$1 = {
                    name: next.name,
                    styles: next.styles,
                    next: cursor$1
                  };
                  next = next.next;
                }
              }

              var styles = interpolation.styles + ";";

              if (interpolation.map !== undefined) {
                styles += interpolation.map;
              }

              return styles;
            }

            return createStringFromObject$1(mergedProps, registered, interpolation);
          }

        case 'function':
          {
            if (mergedProps !== undefined) {
              var previousCursor = cursor$1;
              var result = interpolation(mergedProps);
              cursor$1 = previousCursor;
              return handleInterpolation$1(mergedProps, registered, result);
            } else {
              console.error('Functions that are interpolated in css calls will be stringified.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
            }

            break;
          }

        case 'string':
          {
            var matched = [];
            var replaced = interpolation.replace(animationRegex$1, function (match, p1, p2) {
              var fakeVarName = "animation" + matched.length;
              matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, '') + "`");
              return "${" + fakeVarName + "}";
            });

            if (matched.length) {
              console.error('`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\n' + 'Instead of doing this:\n\n' + [].concat(matched, ["`" + replaced + "`"]).join('\n') + '\n\nYou should wrap it with `css` like this:\n\n' + ("css`" + replaced + "`"));
            }
          }

          break;
      } // finalize string values (regular strings and functions interpolated into css calls)


      if (registered == null) {
        return interpolation;
      }

      var cached = registered[interpolation];
      return cached !== undefined ? cached : interpolation;
    }

    function createStringFromObject$1(mergedProps, registered, obj) {
      var string = '';

      if (Array.isArray(obj)) {
        for (var i = 0; i < obj.length; i++) {
          string += handleInterpolation$1(mergedProps, registered, obj[i]) + ";";
        }
      } else {
        for (var _key in obj) {
          var value = obj[_key];

          if (typeof value !== 'object') {
            if (registered != null && registered[value] !== undefined) {
              string += _key + "{" + registered[value] + "}";
            } else if (isProcessableValue$1(value)) {
              string += processStyleName$1(_key) + ":" + processStyleValue$1(_key, value) + ";";
            }
          } else {
            if (_key === 'NO_COMPONENT_SELECTOR' && "development" !== 'production') {
              throw new Error('Component selectors can only be used in conjunction with @emotion/babel-plugin.');
            }

            if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
              for (var _i = 0; _i < value.length; _i++) {
                if (isProcessableValue$1(value[_i])) {
                  string += processStyleName$1(_key) + ":" + processStyleValue$1(_key, value[_i]) + ";";
                }
              }
            } else {
              var interpolated = handleInterpolation$1(mergedProps, registered, value);

              switch (_key) {
                case 'animation':
                case 'animationName':
                  {
                    string += processStyleName$1(_key) + ":" + interpolated + ";";
                    break;
                  }

                default:
                  {
                    if (_key === 'undefined') {
                      console.error(UNDEFINED_AS_OBJECT_KEY_ERROR$1);
                    }

                    string += _key + "{" + interpolated + "}";
                  }
              }
            }
          }
        }
      }

      return string;
    }

    var labelPattern$1 = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
    var sourceMapPattern$1;

    {
      sourceMapPattern$1 = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
    } // this is the cursor for keyframes
    // keyframes are stored on the SerializedStyles object as a linked list


    var cursor$1;
    var serializeStyles$1 = function serializeStyles(args, registered, mergedProps) {
      if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
        return args[0];
      }

      var stringMode = true;
      var styles = '';
      cursor$1 = undefined;
      var strings = args[0];

      if (strings == null || strings.raw === undefined) {
        stringMode = false;
        styles += handleInterpolation$1(mergedProps, registered, strings);
      } else {
        if (strings[0] === undefined) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$2);
        }

        styles += strings[0];
      } // we start at 1 since we've already handled the first arg


      for (var i = 1; i < args.length; i++) {
        styles += handleInterpolation$1(mergedProps, registered, args[i]);

        if (stringMode) {
          if (strings[i] === undefined) {
            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$2);
          }

          styles += strings[i];
        }
      }

      var sourceMap;

      {
        styles = styles.replace(sourceMapPattern$1, function (match) {
          sourceMap = match;
          return '';
        });
      } // using a global regex with .exec is stateful so lastIndex has to be reset each time


      labelPattern$1.lastIndex = 0;
      var identifierName = '';
      var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

      while ((match = labelPattern$1.exec(styles)) !== null) {
        identifierName += '-' + // $FlowFixMe we know it's not null
        match[1];
      }

      var name = murmur2(styles) + identifierName;

      {
        // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)
        return {
          name: name,
          styles: styles,
          map: sourceMap,
          next: cursor$1,
          toString: function toString() {
            return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
          }
        };
      }
    };

    var isBrowser$2 = typeof document !== 'undefined';
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    var EmotionCacheContext = /* #__PURE__ */React.createContext( // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({
      key: 'css'
    }) : null);
    EmotionCacheContext.Provider;

    var withEmotionCache = function withEmotionCache(func) {
      // $FlowFixMe
      return /*#__PURE__*/React.forwardRef(function (props, ref) {
        // the cache will never be null in the browser
        var cache = React.useContext(EmotionCacheContext);
        return func(props, cache, ref);
      });
    };

    if (!isBrowser$2) {
      withEmotionCache = function withEmotionCache(func) {
        return function (props) {
          var cache = React.useContext(EmotionCacheContext);

          if (cache === null) {
            // yes, we're potentially creating this on every render
            // it doesn't actually matter though since it's only on the server
            // so there will only every be a single render
            // that could change in the future because of suspense and etc. but for now,
            // this works and i don't want to optimise for a future thing that we aren't sure about
            cache = createCache({
              key: 'css'
            });
            return /*#__PURE__*/React.createElement(EmotionCacheContext.Provider, {
              value: cache
            }, func(props, cache));
          } else {
            return func(props, cache);
          }
        };
      };
    }

    var ThemeContext = /* #__PURE__ */React.createContext({});

    var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
    var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';
    var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
      var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
      // not passing the registered cache to serializeStyles because it would
      // make certain babel optimisations not possible

      if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
        cssProp = cache.registered[cssProp];
      }

      var type = props[typePropName];
      var registeredStyles = [cssProp];
      var className = '';

      if (typeof props.className === 'string') {
        className = getRegisteredStyles$1(cache.registered, registeredStyles, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }

      var serialized = serializeStyles$1(registeredStyles, undefined, typeof cssProp === 'function' || Array.isArray(cssProp) ? React.useContext(ThemeContext) : undefined);

      if (serialized.name.indexOf('-') === -1) {
        var labelFromStack = props[labelPropName];

        if (labelFromStack) {
          serialized = serializeStyles$1([serialized, 'label:' + labelFromStack + ';']);
        }
      }

      var rules = insertStyles$1(cache, serialized, typeof type === 'string');
      className += cache.key + "-" + serialized.name;
      var newProps = {};

      for (var key in props) {
        if (hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && (key !== labelPropName)) {
          newProps[key] = props[key];
        }
      }

      newProps.ref = ref;
      newProps.className = className;
      var ele = /*#__PURE__*/React.createElement(type, newProps);

      if (!isBrowser$2 && rules !== undefined) {
        var _ref;

        var serializedNames = serialized.name;
        var next = serialized.next;

        while (next !== undefined) {
          serializedNames += ' ' + next.name;
          next = next.next;
        }

        return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("style", (_ref = {}, _ref["data-emotion"] = cache.key + " " + serializedNames, _ref.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref.nonce = cache.sheet.nonce, _ref)), ele);
      }

      return ele;
    });

    {
      Emotion.displayName = 'EmotionCssPropInternal';
    }

    var isBrowser$1 = typeof document !== 'undefined';
    function getRegisteredStyles(registered, registeredStyles, classNames) {
      var rawClassName = '';
      classNames.split(' ').forEach(function (className) {
        if (registered[className] !== undefined) {
          registeredStyles.push(registered[className] + ";");
        } else {
          rawClassName += className + " ";
        }
      });
      return rawClassName;
    }
    var insertStyles = function insertStyles(cache, serialized, isStringTag) {
      var className = cache.key + "-" + serialized.name;

      if ( // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser$1 === false && cache.compat !== undefined) && cache.registered[className] === undefined) {
        cache.registered[className] = serialized.styles;
      }

      if (cache.inserted[serialized.name] === undefined) {
        var stylesForSSR = '';
        var current = serialized;

        do {
          var maybeStyles = cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

          if (!isBrowser$1 && maybeStyles !== undefined) {
            stylesForSSR += maybeStyles;
          }

          current = current.next;
        } while (current !== undefined);

        if (!isBrowser$1 && stylesForSSR.length !== 0) {
          return stylesForSSR;
        }
      }
    };

    var ILLEGAL_ESCAPE_SEQUENCE_ERROR$1 = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
    var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
    var hyphenateRegex = /[A-Z]|^ms/g;
    var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

    var isCustomProperty = function isCustomProperty(property) {
      return property.charCodeAt(1) === 45;
    };

    var isProcessableValue = function isProcessableValue(value) {
      return value != null && typeof value !== 'boolean';
    };

    var processStyleName = /* #__PURE__ */memoize(function (styleName) {
      return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
    });

    var processStyleValue = function processStyleValue(key, value) {
      switch (key) {
        case 'animation':
        case 'animationName':
          {
            if (typeof value === 'string') {
              return value.replace(animationRegex, function (match, p1, p2) {
                cursor = {
                  name: p1,
                  styles: p2,
                  next: cursor
                };
                return p1;
              });
            }
          }
      }

      if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
        return value + 'px';
      }

      return value;
    };

    {
      var contentValuePattern = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
      var contentValues = ['normal', 'none', 'initial', 'inherit', 'unset'];
      var oldProcessStyleValue = processStyleValue;
      var msPattern = /^-ms-/;
      var hyphenPattern = /-(.)/g;
      var hyphenatedCache = {};

      processStyleValue = function processStyleValue(key, value) {
        if (key === 'content') {
          if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
            throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
          }
        }

        var processed = oldProcessStyleValue(key, value);

        if (processed !== '' && !isCustomProperty(key) && key.indexOf('-') !== -1 && hyphenatedCache[key] === undefined) {
          hyphenatedCache[key] = true;
          console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, 'ms-').replace(hyphenPattern, function (str, _char) {
            return _char.toUpperCase();
          }) + "?");
        }

        return processed;
      };
    }

    function handleInterpolation(mergedProps, registered, interpolation) {
      if (interpolation == null) {
        return '';
      }

      if (interpolation.__emotion_styles !== undefined) {
        if (interpolation.toString() === 'NO_COMPONENT_SELECTOR') {
          throw new Error('Component selectors can only be used in conjunction with @emotion/babel-plugin.');
        }

        return interpolation;
      }

      switch (typeof interpolation) {
        case 'boolean':
          {
            return '';
          }

        case 'object':
          {
            if (interpolation.anim === 1) {
              cursor = {
                name: interpolation.name,
                styles: interpolation.styles,
                next: cursor
              };
              return interpolation.name;
            }

            if (interpolation.styles !== undefined) {
              var next = interpolation.next;

              if (next !== undefined) {
                // not the most efficient thing ever but this is a pretty rare case
                // and there will be very few iterations of this generally
                while (next !== undefined) {
                  cursor = {
                    name: next.name,
                    styles: next.styles,
                    next: cursor
                  };
                  next = next.next;
                }
              }

              var styles = interpolation.styles + ";";

              if (interpolation.map !== undefined) {
                styles += interpolation.map;
              }

              return styles;
            }

            return createStringFromObject(mergedProps, registered, interpolation);
          }

        case 'function':
          {
            if (mergedProps !== undefined) {
              var previousCursor = cursor;
              var result = interpolation(mergedProps);
              cursor = previousCursor;
              return handleInterpolation(mergedProps, registered, result);
            } else {
              console.error('Functions that are interpolated in css calls will be stringified.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
            }

            break;
          }

        case 'string':
          {
            var matched = [];
            var replaced = interpolation.replace(animationRegex, function (match, p1, p2) {
              var fakeVarName = "animation" + matched.length;
              matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, '') + "`");
              return "${" + fakeVarName + "}";
            });

            if (matched.length) {
              console.error('`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\n' + 'Instead of doing this:\n\n' + [].concat(matched, ["`" + replaced + "`"]).join('\n') + '\n\nYou should wrap it with `css` like this:\n\n' + ("css`" + replaced + "`"));
            }
          }

          break;
      } // finalize string values (regular strings and functions interpolated into css calls)


      if (registered == null) {
        return interpolation;
      }

      var cached = registered[interpolation];
      return cached !== undefined ? cached : interpolation;
    }

    function createStringFromObject(mergedProps, registered, obj) {
      var string = '';

      if (Array.isArray(obj)) {
        for (var i = 0; i < obj.length; i++) {
          string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
        }
      } else {
        for (var _key in obj) {
          var value = obj[_key];

          if (typeof value !== 'object') {
            if (registered != null && registered[value] !== undefined) {
              string += _key + "{" + registered[value] + "}";
            } else if (isProcessableValue(value)) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
            }
          } else {
            if (_key === 'NO_COMPONENT_SELECTOR' && "development" !== 'production') {
              throw new Error('Component selectors can only be used in conjunction with @emotion/babel-plugin.');
            }

            if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
              for (var _i = 0; _i < value.length; _i++) {
                if (isProcessableValue(value[_i])) {
                  string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
                }
              }
            } else {
              var interpolated = handleInterpolation(mergedProps, registered, value);

              switch (_key) {
                case 'animation':
                case 'animationName':
                  {
                    string += processStyleName(_key) + ":" + interpolated + ";";
                    break;
                  }

                default:
                  {
                    if (_key === 'undefined') {
                      console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                    }

                    string += _key + "{" + interpolated + "}";
                  }
              }
            }
          }
        }
      }

      return string;
    }

    var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
    var sourceMapPattern;

    {
      sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
    } // this is the cursor for keyframes
    // keyframes are stored on the SerializedStyles object as a linked list


    var cursor;
    var serializeStyles = function serializeStyles(args, registered, mergedProps) {
      if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
        return args[0];
      }

      var stringMode = true;
      var styles = '';
      cursor = undefined;
      var strings = args[0];

      if (strings == null || strings.raw === undefined) {
        stringMode = false;
        styles += handleInterpolation(mergedProps, registered, strings);
      } else {
        if (strings[0] === undefined) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1);
        }

        styles += strings[0];
      } // we start at 1 since we've already handled the first arg


      for (var i = 1; i < args.length; i++) {
        styles += handleInterpolation(mergedProps, registered, args[i]);

        if (stringMode) {
          if (strings[i] === undefined) {
            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1);
          }

          styles += strings[i];
        }
      }

      var sourceMap;

      {
        styles = styles.replace(sourceMapPattern, function (match) {
          sourceMap = match;
          return '';
        });
      } // using a global regex with .exec is stateful so lastIndex has to be reset each time


      labelPattern.lastIndex = 0;
      var identifierName = '';
      var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

      while ((match = labelPattern.exec(styles)) !== null) {
        identifierName += '-' + // $FlowFixMe we know it's not null
        match[1];
      }

      var name = murmur2(styles) + identifierName;

      {
        // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)
        return {
          name: name,
          styles: styles,
          map: sourceMap,
          next: cursor,
          toString: function toString() {
            return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
          }
        };
      }
    };

    var testOmitPropsOnStringTag = isPropValid;

    var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
      return key !== 'theme';
    };

    var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
      return typeof tag === 'string' && // 96 is one less than the char code
      // for "a" so this is checking that
      // it's a lowercase character
      tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
    };
    var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
      var shouldForwardProp;

      if (options) {
        var optionsShouldForwardProp = options.shouldForwardProp;
        shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
          return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
        } : optionsShouldForwardProp;
      }

      if (typeof shouldForwardProp !== 'function' && isReal) {
        shouldForwardProp = tag.__emotion_forwardProp;
      }

      return shouldForwardProp;
    };

    var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
    var isBrowser = typeof document !== 'undefined';

    var createStyled = function createStyled(tag, options) {
      {
        if (tag === undefined) {
          throw new Error('You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.');
        }
      }

      var isReal = tag.__emotion_real === tag;
      var baseTag = isReal && tag.__emotion_base || tag;
      var identifierName;
      var targetClassName;

      if (options !== undefined) {
        identifierName = options.label;
        targetClassName = options.target;
      }

      var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
      var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
      var shouldUseAs = !defaultShouldForwardProp('as');
      return function () {
        var args = arguments;
        var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];

        if (identifierName !== undefined) {
          styles.push("label:" + identifierName + ";");
        }

        if (args[0] == null || args[0].raw === undefined) {
          styles.push.apply(styles, args);
        } else {
          if (args[0][0] === undefined) {
            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
          }

          styles.push(args[0][0]);
          var len = args.length;
          var i = 1;

          for (; i < len; i++) {
            if (args[0][i] === undefined) {
              console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
            }

            styles.push(args[i], args[0][i]);
          }
        } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class


        var Styled = withEmotionCache(function (props, cache, ref) {
          var finalTag = shouldUseAs && props.as || baseTag;
          var className = '';
          var classInterpolations = [];
          var mergedProps = props;

          if (props.theme == null) {
            mergedProps = {};

            for (var key in props) {
              mergedProps[key] = props[key];
            }

            mergedProps.theme = React.useContext(ThemeContext);
          }

          if (typeof props.className === 'string') {
            className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
          } else if (props.className != null) {
            className = props.className + " ";
          }

          var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
          var rules = insertStyles(cache, serialized, typeof finalTag === 'string');
          className += cache.key + "-" + serialized.name;

          if (targetClassName !== undefined) {
            className += " " + targetClassName;
          }

          var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(finalTag) : defaultShouldForwardProp;
          var newProps = {};

          for (var _key in props) {
            if (shouldUseAs && _key === 'as') continue;

            if ( // $FlowFixMe
            finalShouldForwardProp(_key)) {
              newProps[_key] = props[_key];
            }
          }

          newProps.className = className;
          newProps.ref = ref;
          var ele = /*#__PURE__*/React.createElement(finalTag, newProps);

          if (!isBrowser && rules !== undefined) {
            var _ref;

            var serializedNames = serialized.name;
            var next = serialized.next;

            while (next !== undefined) {
              serializedNames += ' ' + next.name;
              next = next.next;
            }

            return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("style", (_ref = {}, _ref["data-emotion"] = cache.key + " " + serializedNames, _ref.dangerouslySetInnerHTML = {
              __html: rules
            }, _ref.nonce = cache.sheet.nonce, _ref)), ele);
          }

          return ele;
        });
        Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
        Styled.defaultProps = tag.defaultProps;
        Styled.__emotion_real = Styled;
        Styled.__emotion_base = baseTag;
        Styled.__emotion_styles = styles;
        Styled.__emotion_forwardProp = shouldForwardProp;
        Object.defineProperty(Styled, 'toString', {
          value: function value() {
            if (targetClassName === undefined && "development" !== 'production') {
              return 'NO_COMPONENT_SELECTOR';
            } // $FlowFixMe: coerce undefined to string


            return "." + targetClassName;
          }
        });

        Styled.withComponent = function (nextTag, nextOptions) {
          return createStyled(nextTag, _extends({}, options, nextOptions, {
            shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
          })).apply(void 0, styles);
        };

        return Styled;
      };
    };

    var tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
    'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];

    var newStyled = createStyled.bind();
    tags.forEach(function (tagName) {
      // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type
      newStyled[tagName] = newStyled(tagName);
    });

    var paraGraphDefaultStyle = {
        fontSize: 13,
        lineHeight: '20px',
    };
    var Button = newStyled.button(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  appearance: none;\n  margin: 0;\n  border: 0;\n  color: white;\n  padding: 5px !important;\n  border-radius: 0 !important;\n  background: ", ";\n  transition: 0.2s all;\n\n  &:hover {\n    background: ", ";\n  }\n"], ["\n  appearance: none;\n  margin: 0;\n  border: 0;\n  color: white;\n  padding: 5px !important;\n  border-radius: 0 !important;\n  background: ",
        ";\n  transition: 0.2s all;\n\n  &:hover {\n    background: ", ";\n  }\n"])), function (props) {
        return props.hideBackground ? "" : colors.blue + " !important";
    }, colors.lightBlue);
    Button.defaultProps = { type: 'button' };
    var CircleButton = newStyled(Button)(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  font-size: 14px;\n  font-weight: bold;\n  margin: 0 4px 0 auto;\n  background: none !important;\n  display: flex;\n  width: 25px;\n  height: 25px;\n  justify-content: center;\n  line-height: 14px !important;\n  border-radius: 50% !important;\n  padding: 0 !important;\n  transition: 0.2s all;\n\n  &:hover {\n    background: ", ";\n  }\n\n  &:active {\n    background: black;\n  }\n"], ["\n  font-size: 14px;\n  font-weight: bold;\n  margin: 0 4px 0 auto;\n  background: none !important;\n  display: flex;\n  width: 25px;\n  height: 25px;\n  justify-content: center;\n  line-height: 14px !important;\n  border-radius: 50% !important;\n  padding: 0 !important;\n  transition: 0.2s all;\n\n  &:hover {\n    background: ", ";\n  }\n\n  &:active {\n    background: black;\n  }\n"])), colors.lightBlue);
    var Input = newStyled.input(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  &::placeholder {\n    color: #b3b3b3;\n  }\n\n  &:focus::placeholder {\n    color: white;\n  }\n"], ["\n  &::placeholder {\n    color: #b3b3b3;\n  }\n\n  &:focus::placeholder {\n    color: white;\n  }\n"])));
    var Table = newStyled.table(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n  transition: 0.3s all;\n\n  &:hover {\n    background: ", ";\n  }\n"], ["\n  transition: 0.3s all;\n\n  &:hover {\n    background: ", ";\n  }\n"])), colors.primary);
    var templateObject_1, templateObject_2, templateObject_3, templateObject_4;

    var Header = function (_a) {
        var setVisible = _a.setVisible, control = _a.control;
        var isValid = reactHookForm.useFormState({
            control: control,
        }).isValid;
        return (React__namespace.createElement("header", { style: {
                display: 'flex',
                alignItems: 'center',
                paddingLeft: 10,
                backgroundColor: 'transparent',
            } },
            React__namespace.createElement("p", { style: __assign(__assign({}, paraGraphDefaultStyle), { margin: 0, padding: 0, fontWeight: 400, fontSize: 12 }) },
                React__namespace.createElement("span", { style: {
                        transition: '0.5s all',
                        color: isValid ? colors.green : colors.lightPink,
                    } }, "\u25A0"),
                ' ',
                "React Hook Form"),
            React__namespace.createElement(CircleButton, { title: "Close dev panel", onClick: function () { return setVisible(false); } }, "\u2715")));
    };

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    var isUndefined_1 = isUndefined;

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    var isObject_1 = isObject;

    var PanelTable = function (_a) {
        var refObject = _a.refObject, hasError = _a.hasError, isDirty = _a.isDirty, fieldsValues = _a.fieldsValues, isNative = _a.isNative, errorMessage = _a.errorMessage, errorType = _a.errorType, type = _a.type, isTouched = _a.isTouched, name = _a.name, collapseAll = _a.collapseAll;
        var _b = React__namespace.useState(false), collapse = _b[0], setCollapse = _b[1];
        React__namespace.useEffect(function () {
            setCollapse(!collapseAll);
        }, [collapseAll]);
        var value = fieldsValues ? reactHookForm.get(fieldsValues, name) : '';
        var isValueWrappedInPre = false;
        if (!isUndefined_1(value)) {
            if (isObject_1(value)) {
                try {
                    value = (React__namespace.createElement("pre", { style: { margin: 0 } },
                        React__namespace.createElement("code", { style: { fontSize: 12 } }, JSON.stringify(value, null, 2))));
                    isValueWrappedInPre = true;
                }
                catch (_c) {
                    value = React__namespace.createElement("span", null, "[Nested Object]");
                }
            }
            else if (typeof value !== 'string') {
                value = String(value);
            }
        }
        return (React__namespace.createElement(Table, { style: {
                padding: '5px 8px',
                width: '100%',
                transition: '.3s all',
                borderLeft: "2px solid " + (hasError ? colors.secondary : colors.buttonBlue),
                background: 'none',
            } },
            React__namespace.createElement("thead", null,
                React__namespace.createElement("tr", null,
                    React__namespace.createElement("td", { valign: "top", style: { width: 85, lineHeight: '22px' } },
                        React__namespace.createElement(Button, { onClick: function () { return setCollapse(!collapse); }, title: "Toggle field table", style: {
                                border: "1px solid " + colors.lightBlue,
                                borderRadius: 2,
                                padding: '3px 5px',
                                display: 'inline-block',
                                fontSize: 9,
                                lineHeight: '13px',
                                width: 20,
                                textAlign: 'center',
                                marginRight: 8,
                            } }, collapse ? '+' : '-'),
                        React__namespace.createElement(Button, { onClick: function () {
                                if (refObject.scrollIntoView) {
                                    refObject.scrollIntoView({ behavior: 'smooth' });
                                }
                            }, title: "Scroll into view", style: __assign({ border: "1px solid " + colors.lightBlue, borderRadius: 2, padding: '3px 5px', display: 'inline-block', fontSize: 9, lineHeight: '13px', textAlign: 'center', width: 'calc(100% - 30px)' }, (isNative
                                ? {}
                                : { cursor: 'not-allowed', background: colors.lightBlue })) }, isNative ? 'Native' : 'Custom')),
                    React__namespace.createElement("td", { style: {
                            display: 'block',
                            maxWidth: 140,
                        } },
                        React__namespace.createElement("p", { style: __assign(__assign({ margin: 0, padding: 0, top: 0, position: 'relative', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }, paraGraphDefaultStyle), { lineHeight: '24px' }), title: name }, name)))),
            !collapse && (React__namespace.createElement("tbody", null,
                type && (React__namespace.createElement("tr", null,
                    React__namespace.createElement("td", { align: "right", style: __assign({ paddingRight: 5, fontWeight: 500, verticalAlign: 'top' }, paraGraphDefaultStyle) }, "Type:"),
                    React__namespace.createElement("td", { style: __assign({ display: 'block', maxWidth: 100 }, paraGraphDefaultStyle) }, type))),
                errorType && (React__namespace.createElement("tr", null,
                    React__namespace.createElement("td", { align: "right", style: __assign({ paddingRight: 5, fontWeight: 500, verticalAlign: 'top' }, paraGraphDefaultStyle) }, "ERROR Type:"),
                    React__namespace.createElement("td", { style: __assign({ display: 'block', maxWidth: 100 }, paraGraphDefaultStyle) }, errorType))),
                errorMessage && (React__namespace.createElement("tr", null,
                    React__namespace.createElement("td", { align: "right", style: __assign({ paddingRight: 5, fontWeight: 500, verticalAlign: 'top' }, paraGraphDefaultStyle) }, "MESSAGE:"),
                    React__namespace.createElement("td", { style: __assign({ display: 'block', maxWidth: 100 }, paraGraphDefaultStyle) }, errorMessage.trim()))),
                !isUndefined_1(value) && (React__namespace.createElement("tr", null,
                    React__namespace.createElement("td", { align: "right", style: __assign({ paddingRight: 5, fontWeight: 500, verticalAlign: 'top' }, paraGraphDefaultStyle) }, "Value:"),
                    React__namespace.createElement("td", { "data-testid": name + "-field-value", style: __assign({ display: 'block', maxWidth: 100 }, paraGraphDefaultStyle) },
                        !isValueWrappedInPre && (React__namespace.createElement("p", { title: value, style: __assign(__assign({}, paraGraphDefaultStyle), { margin: 0, padding: 0 }) }, value)),
                        isValueWrappedInPre && (React__namespace.createElement("div", { style: __assign(__assign({}, paraGraphDefaultStyle), { margin: 0, padding: 0 }) }, value))))),
                React__namespace.createElement("tr", null,
                    React__namespace.createElement("td", { align: "right", style: __assign({ paddingRight: 5, fontWeight: 500, verticalAlign: 'top' }, paraGraphDefaultStyle) }, "Touched:"),
                    React__namespace.createElement("td", null,
                        React__namespace.createElement("code", { style: __assign(__assign({ color: isTouched ? colors.green : colors.lightPink }, paraGraphDefaultStyle), { fontSize: 12 }) }, isTouched ? 'true' : 'false'))),
                React__namespace.createElement("tr", null,
                    React__namespace.createElement("td", { align: "right", style: __assign({ paddingRight: 5, fontWeight: 500, verticalAlign: 'top' }, paraGraphDefaultStyle) }, "Dirty:"),
                    React__namespace.createElement("td", null,
                        React__namespace.createElement("code", { style: __assign(__assign({ color: isDirty ? colors.green : colors.lightPink }, paraGraphDefaultStyle), { fontSize: 12 }) }, isDirty ? 'true' : 'false')))))));
    };

    var FormStateTable = function (_a) {
        var formState = _a.formState, showFormState = _a.showFormState, setShowFormState = _a.setShowFormState;
        return (React__namespace.createElement("div", { style: {
                alignSelf: 'end',
            } },
            React__namespace.createElement(Animate_1, { play: showFormState, start: { opacity: 0 }, end: { opacity: 1 }, render: function (_a) {
                    var style = _a.style;
                    return (React__namespace.createElement("table", { style: __assign({ padding: '5px 10px', display: 'block', background: 'black', borderTop: "1px solid " + colors.lightPink, pointerEvents: 'none' }, style) },
                        React__namespace.createElement("tbody", null,
                            React__namespace.createElement("tr", null,
                                React__namespace.createElement("td", { align: "right", style: __assign({ width: 90 }, paraGraphDefaultStyle) }, "Valid:"),
                                React__namespace.createElement("td", { style: __assign({ color: formState.isValid ? colors.green : colors.lightPink }, paraGraphDefaultStyle) }, formState.isValid ? 'true' : 'false')),
                            React__namespace.createElement("tr", null,
                                React__namespace.createElement("td", { align: "right", style: __assign({}, paraGraphDefaultStyle) }, "Submitted:"),
                                React__namespace.createElement("td", { style: __assign({ color: formState.isSubmitted
                                            ? colors.green
                                            : colors.lightPink }, paraGraphDefaultStyle) }, formState.isSubmitted ? 'true' : 'false')),
                            React__namespace.createElement("tr", null,
                                React__namespace.createElement("td", { align: "right", style: __assign({}, paraGraphDefaultStyle) }, "Count:"),
                                React__namespace.createElement("td", { style: __assign({ color: formState.submitCount
                                            ? colors.green
                                            : colors.lightPink }, paraGraphDefaultStyle) }, formState.submitCount)),
                            React__namespace.createElement("tr", null,
                                React__namespace.createElement("td", { align: "right", style: __assign({}, paraGraphDefaultStyle) }, "Submitting:"),
                                React__namespace.createElement("td", { style: __assign({ color: formState.isSubmitting
                                            ? colors.green
                                            : colors.lightPink }, paraGraphDefaultStyle) }, formState.isSubmitting ? 'true' : 'false')))));
                } }),
            React__namespace.createElement(Button, { style: {
                    margin: 0,
                    width: '100%',
                    padding: '8px 10px',
                    textTransform: 'none',
                    fontSize: 12,
                    lineHeight: '14px',
                }, title: "Toggle form state panel", onClick: function () {
                    setShowFormState(!showFormState);
                } },
                React__namespace.createElement("span", { style: {
                        transition: '0.5s all',
                        color: formState.isValid ? colors.green : colors.lightPink,
                    } }, "\u25A0"),
                ' ',
                "Form State: ",
                showFormState ? 'OFF' : 'ON')));
    };

    function setVisible(state, payload) {
        return __assign(__assign({}, state), { visible: payload });
    }
    function setCollapse(state, payload) {
        return __assign(__assign({}, state), { isCollapse: payload });
    }

    var childIndex = 0;
    function PanelChildren(_a) {
        var fields = _a.fields, searchTerm = _a.searchTerm, touchedFields = _a.touchedFields, errors = _a.errors, dirtyFields = _a.dirtyFields, state = _a.state, fieldsValues = _a.fieldsValues;
        return (React__namespace.createElement(React__namespace.Fragment, null, fields &&
            Object.entries(fields)
                .filter(function (_a) {
                var name = _a[0];
                return ((name &&
                    name.toLowerCase &&
                    name.toLowerCase().includes(searchTerm)) ||
                    (!name && !searchTerm) ||
                    searchTerm === '') &&
                    name;
            })
                .map(function (_a, index) {
                var name = _a[0], value = _a[1];
                childIndex++;
                if (!(value === null || value === void 0 ? void 0 : value._f)) {
                    return (React__namespace.createElement(PanelChildren, __assign({ key: name + childIndex }, {
                        fields: value,
                        searchTerm: searchTerm,
                        touchedFields: touchedFields,
                        errors: errors,
                        dirtyFields: dirtyFields,
                        state: state,
                        fieldsValues: fieldsValues,
                    })));
                }
                else {
                    var error = reactHookForm.get(errors, value._f.name);
                    var errorMessage = reactHookForm.get(error, 'message', undefined);
                    var errorType = reactHookForm.get(error, 'type', undefined);
                    var type = reactHookForm.get(value, 'ref.type', undefined);
                    var isTouched = !!reactHookForm.get(touchedFields, value._f.name);
                    var isNative = !!(value && value._f.ref.type);
                    var isDirty = !!reactHookForm.get(dirtyFields, value._f.name);
                    var hasError = !!error;
                    var ref = reactHookForm.get(value, '_f.ref');
                    return (React__namespace.createElement("section", { key: (value === null || value === void 0 ? void 0 : value._f.name) + childIndex, style: {
                            borderBottom: "1px dashed " + colors.secondary,
                            margin: 0,
                        } },
                        React__namespace.createElement(PanelTable, { refObject: ref, index: index, collapseAll: state.isCollapse, name: value === null || value === void 0 ? void 0 : value._f.name, isTouched: isTouched, type: type, hasError: hasError, isNative: isNative, errorMessage: errorMessage, errorType: errorType, isDirty: isDirty, fieldsValues: fieldsValues })));
                }
            })));
    }
    var Panel = function (_a) {
        var control = _a.control, _fields = _a.control._fields;
        var formState = reactHookForm.useFormState({
            control: control,
        });
        var dirtyFields = formState.dirtyFields, touchedFields = formState.touchedFields, errors = formState.errors;
        formState.isDirty;
        var _b = d({
            setCollapse: setCollapse,
        }), state = _b.state, actions = _b.actions;
        var _c = React__namespace.useState({}), setData = _c[1];
        var _d = React__namespace.useState(false), showFormState = _d[0], setShowFormState = _d[1];
        var fieldsValues = reactHookForm.useWatch({
            control: control,
        });
        var _e = reactHookForm.useForm(), register = _e.register, watch = _e.watch;
        var searchTerm = watch('search', '');
        React.useEffect(function () {
            setData({});
        }, []);
        return (React__namespace.createElement("div", { style: {
                display: 'grid',
                gridTemplateRows: '56px auto',
                height: 'calc(100vh - 40px)',
            } },
            React__namespace.createElement("div", { style: {
                    display: 'grid',
                    gridTemplateColumns: "1fr 1fr",
                    gridTemplateRows: '28px 28px',
                } },
                React__namespace.createElement(Button, { style: {
                        borderRight: "1px solid " + colors.primary,
                        textTransform: 'none',
                        fontSize: 11,
                        lineHeight: 1,
                    }, title: "Update values and state the form", onClick: function () { return setData({}); } }, "\u267A REFRESH"),
                React__namespace.createElement(Button, { style: {
                        borderRight: "1px solid " + colors.primary,
                        textTransform: 'none',
                        fontSize: 11,
                        lineHeight: 1,
                    }, title: "Toggle entire fields", onClick: function () {
                        actions.setCollapse(!state.isCollapse);
                    } }, state.isCollapse ? '[-] COLLAPSE' : '[+] EXPAND'),
                React__namespace.createElement(Input, __assign({ style: {
                        display: 'inline-block',
                        borderRadius: 0,
                        width: '100%',
                        margin: 0,
                        padding: '5px 10px',
                        WebkitAppearance: 'none',
                        appearance: 'none',
                        fontSize: 14,
                        border: 0,
                        color: 'white',
                        gridColumnStart: 1,
                        gridColumnEnd: 4,
                        background: 'black',
                    } }, register('search'), { placeholder: "Filter name...", type: "search" }))),
            React__namespace.createElement("div", { style: {
                    overflow: 'auto',
                } },
                React__namespace.createElement(PanelChildren, { fields: _fields, searchTerm: searchTerm, errors: errors, touchedFields: touchedFields, dirtyFields: dirtyFields, fieldsValues: fieldsValues, state: state })),
            React__namespace.createElement(FormStateTable, { formState: formState, showFormState: showFormState, setShowFormState: setShowFormState })));
    };

    var Logo = function (_a) {
        var style = _a.style, actions = _a.actions;
        return (React__namespace.createElement("svg", { fill: "white", viewBox: "0 0 100 100", style: __assign({ height: 14, padding: 3, borderRadius: 2, background: colors.lightPink }, style), onClick: function () {
                actions.setVisible(true);
            }, "aria-label": "React Hook Form Logo" },
            React__namespace.createElement("path", { d: "M73.56,13.32H58.14a8.54,8.54,0,0,0-16.27,0H26.44a11,11,0,0,0-11,11V81.63a11,11,0,0,0,11,11H73.56a11,11,0,0,0,11-11V24.32A11,11,0,0,0,73.56,13.32Zm-30.92,2a1,1,0,0,0,1-.79,6.54,6.54,0,0,1,12.78,0,1,1,0,0,0,1,.79h5.38v6.55a3,3,0,0,1-3,3H40.25a3,3,0,0,1-3-3V15.32ZM82.56,81.63a9,9,0,0,1-9,9H26.44a9,9,0,0,1-9-9V24.32a9,9,0,0,1,9-9h8.81v6.55a5,5,0,0,0,5,5h19.5a5,5,0,0,0,5-5V15.32h8.81a9,9,0,0,1,9,9Z" }),
            React__namespace.createElement("path", { style: { transform: 'translateX(-25px)' }, d: "M71.6,45.92H54a1,1,0,0,0,0,2H71.6a1,1,0,0,0,0-2Z" }),
            React__namespace.createElement("path", { d: "M71.6,45.92H54a1,1,0,0,0,0,2H71.6a1,1,0,0,0,0-2Z" }),
            React__namespace.createElement("path", { style: { transform: 'translateX(-25px)' }, d: "M71.1,69.49H53.45a1,1,0,1,0,0,2H71.1a1,1,0,0,0,0-2Z" }),
            React__namespace.createElement("path", { d: "M71.1,69.49H53.45a1,1,0,1,0,0,2H71.1a1,1,0,0,0,0-2Z" })));
    };

    function getPositionByPlacement(placement, defaultX, defaultY) {
        var _a;
        if (defaultX === void 0) { defaultX = 0; }
        if (defaultY === void 0) { defaultY = 0; }
        var _b = placement.split('-'), x = _b[0], y = _b[1];
        return _a = {},
            _a[x] = defaultX,
            _a[y] = defaultY,
            _a;
    }

    var DevToolUI = function (_a) {
        var control = _a.control, _b = _a.placement, placement = _b === void 0 ? 'top-right' : _b;
        var _c = d({
            setVisible: setVisible,
        }), state = _c.state, actions = _c.actions;
        var position = getPositionByPlacement(placement, 0, 0);
        return (React__namespace.createElement(React__namespace.Fragment, null,
            React__namespace.createElement(Animate_1, { play: state.visible, duration: 0.2, start: __assign(__assign({}, position), { position: 'fixed', transform: placement.includes('right')
                        ? 'translateX(280px)'
                        : 'translateX(-280px)', zIndex: 99999 }), end: __assign(__assign({}, position), { position: 'fixed', transform: 'translateX(0)', zIndex: 99999 }) },
                React__namespace.createElement("div", { style: __assign(__assign({}, position), { position: 'fixed', height: '100vh', width: 250, zIndex: 99999, background: colors.buttonBlue, display: 'grid', textAlign: 'left', color: 'white', fontSize: 14, gridTemplateRows: '40px auto', fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif" }) },
                    React__namespace.createElement(Header, { setVisible: actions.setVisible, control: control }),
                    React__namespace.createElement(Panel, { control: control }))),
            !state.visible && (React__namespace.createElement(Button, { title: "Show dev panel", hideBackground: true, style: __assign(__assign({ position: 'fixed', zIndex: 99999 }, getPositionByPlacement(placement, 3, 3)), { padding: 3, margin: 0, background: 'none' }) },
                React__namespace.createElement(Logo, { actions: actions })))));
    };

    if (typeof window !== 'undefined') {
        _({
            visible: true,
            isCollapse: false,
            filterName: '',
        }, {
            name: '__REACT_HOOK_FORM_DEVTOOLS__',
            middleWares: [],
            storageType: window.localStorage,
        });
    }
    var DevTool = function (props) {
        var methods = reactHookForm.useFormContext();
        return (React__namespace.createElement(s, null,
            React__namespace.createElement(DevToolUI, { control: (props && props.control) || methods.control, placement: props === null || props === void 0 ? void 0 : props.placement })));
    };

    exports.DevTool = DevTool;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.development.js.map
